{
  "version": "1.0",
  "backup": true,
  "changes": [
    {
      "op": "write_file",
      "id": "update_github_api_py",
      "description": "Improve GHClient: robust repo URL parsing (supports SSH), paginate branches, clearer errors",
      "path": "modular-framework/modules/github-hub/app/github_api.py",
      "mode": "overwrite",
      "content": "from __future__ import annotations\nimport base64, json\nfrom typing import Dict, Any, List, Optional, Tuple\nimport requests\nfrom loguru import logger\nfrom urllib.parse import urlparse\n\nclass GHClient:\n    def __init__(self, token: str, base_url: str = \"https://api.github.com\"):\n        self.token = token\n        self.base_url = base_url.rstrip(\"/\")\n\n    def _h(self):\n        return {\n            \"Authorization\": f\"Bearer {self.token}\",\n            \"Accept\": \"application/vnd.github+json\",\n            \"X-GitHub-Api-Version\": \"2022-11-28\",\n        }\n\n    @staticmethod\n    def parse_repo(url: str) -> Tuple[str, str]:\n        \"\"\"\n        Supports:\n          - https://github.com/owner/repo(.git)\n          - https://ghe.company.tld/org/repo(.git)\n          - git@github.com:owner/repo(.git)\n        Returns (owner, repo) or raises ValueError.\n        \"\"\"\n        if not url or not isinstance(url, str):\n            raise ValueError(\"repo_url is required\")\n        u = url.strip()\n        # SSH style: git@host:owner/repo.git\n        if \"@\" in u and \":\" in u and not u.startswith(\"http\"):\n            try:\n                path = u.split(\":\", 1)[1]\n                parts = [p for p in path.split(\"/\") if p]\n                if len(parts) < 2:\n                    raise ValueError\n                owner, repo = parts[-2], parts[-1].removesuffix(\".git\")\n                return owner, repo\n            except Exception:\n                raise ValueError(f\"Invalid SSH repo URL: {url}\")\n        # HTTP(S) style\n        try:\n            parsed = urlparse(u)\n            parts = [p for p in parsed.path.split(\"/\") if p]\n            if len(parts) < 2:\n                raise ValueError\n            owner, repo = parts[-2], parts[-1].removesuffix(\".git\")\n            return owner, repo\n        except Exception:\n            raise ValueError(f\"Invalid repo URL: {url}\")\n\n    # ----- simple endpoints -----\n    def get_branches(self, owner: str, repo: str, per_page: int = 100, max_pages: int = 20) -> List[str]:\n        \"\"\"List branches with pagination to avoid truncation on large repos.\"\"\"\n        names: List[str] = []\n        seen = set()\n        for page in range(1, max_pages + 1):\n            r = requests.get(\n                f\"{self.base_url}/repos/{owner}/{repo}/branches\",\n                headers=self._h(),\n                params={\"per_page\": per_page, \"page\": page},\n                timeout=30,\n            )\n            if r.status_code == 404:\n                raise requests.HTTPError(f\"Repository not found or no access to {owner}/{repo}\", response=r)\n            r.raise_for_status()\n            batch = r.json() or []\n            for b in batch:\n                n = b.get(\"name\")\n                if n and n not in seen:\n                    seen.add(n)\n                    names.append(n)\n            if len(batch) < per_page:\n                break\n        return names\n\n    def get_branch_sha(self, owner: str, repo: str, branch: str) -> str:\n        r = requests.get(f\"{self.base_url}/repos/{owner}/{repo}/branches/{branch}\", headers=self._h(), timeout=20)\n        if r.status_code == 404:\n            raise requests.HTTPError(f\"Branch '{branch}' not found in {owner}/{repo}\", response=r)\n        r.raise_for_status()\n        return r.json()[\"commit\"][\"sha\"]\n\n    def get_tree(self, owner: str, repo: str, branch: str, recursive: bool = True) -> Dict[str, Any]:\n        sha = self.get_branch_sha(owner, repo, branch)\n        url = f\"{self.base_url}/repos/{owner}/{repo}/git/trees/{sha}\"\n        if recursive:\n            url += \"?recursive=1\"\n        r = requests.get(url, headers=self._h(), timeout=60)\n        r.raise_for_status()\n        return r.json()\n\n    def get_file(self, owner: str, repo: str, path: str, ref: Optional[str] = None) -> Dict[str, Any]:\n        params = {\"ref\": ref} if ref else None\n        r = requests.get(f\"{self.base_url}/repos/{owner}/{repo}/contents/{path}\", headers=self._h(), params=params, timeout=30)\n        r.raise_for_status()\n        data = r.json()\n        content_b64 = data.get(\"content\") or \"\"\n        decoded = base64.b64decode(content_b64.encode(\"utf-8\")).decode(\"utf-8\", errors=\"ignore\") if content_b64 else \"\"\n        return {**data, \"decoded_content\": decoded}\n\n    def put_file(self, owner: str, repo: str, path: str, message: str, content: str, branch: Optional[str], sha: Optional[str]) -> Dict[str, Any]:\n        payload = {\n            \"message\": message,\n            \"content\": base64.b64encode(content.encode(\"utf-8\")).decode(\"utf-8\"),\n        }\n        if branch: payload[\"branch\"] = branch\n        if sha: payload[\"sha\"] = sha\n        r = requests.put(f\"{self.base_url}/repos/{owner}/{repo}/contents/{path}\", headers=self._h(), json=payload, timeout=60)\n        r.raise_for_status()\n        return r.json()\n\n    def delete_file(self, owner: str, repo: str, path: str, message: str, sha: str, branch: Optional[str]) -> Dict[str, Any]:\n        payload = {\"message\": message, \"sha\": sha}\n        if branch: payload[\"branch\"] = branch\n        r = requests.delete(f\"{self.base_url}/repos/{owner}/{repo}/contents/{path}\", headers=self._h(), json=payload, timeout=30)\n        r.raise_for_status()\n        return r.json()\n\n    def create_branch(self, owner: str, repo: str, new_branch: str, from_branch: str) -> Dict[str, Any]:\n        base_sha = self.get_branch_sha(owner, repo, from_branch)\n        payload = {\"ref\": f\"refs/heads/{new_branch}\", \"sha\": base_sha}\n        r = requests.post(f\"{self.base_url}/repos/{owner}/{repo}/git/refs\", headers=self._h(), json=payload, timeout=30)\n        r.raise_for_status()\n        return r.json()\n\n    # Pull requests\n    def create_pull_request(self, owner: str, repo: str, title: str, head: str, base: str, body: Optional[str] = None, draft: bool = False) -> Dict[str, Any]:\n        payload = {\"title\": title, \"head\": head, \"base\": base}\n        if body: payload[\"body\"] = body\n        if draft: payload[\"draft\"] = True\n        r = requests.post(f\"{self.base_url}/repos/{owner}/{repo}/pulls\", headers=self._h(), json=payload, timeout=60)\n        r.raise_for_status()\n        return r.json()\n\n    # ----- batch commit (single commit for many files) -----\n    def get_commit_and_tree(self, owner: str, repo: str, branch: str) -> tuple[str, str]:\n        ref = requests.get(f\"{self.base_url}/repos/{owner}/{repo}/git/ref/heads/{branch}\", headers=self._h(), timeout=30)\n        ref.raise_for_status()\n        commit_sha = ref.json()[\"object\"][\"sha\"]\n        commit = requests.get(f\"{self.base_url}/repos/{owner}/{repo}/git/commits/{commit_sha}\", headers=self._h(), timeout=30)\n        commit.raise_for_status()\n        tree_sha = commit.json()[\"tree\"][\"sha\"]\n        return commit_sha, tree_sha\n\n    def create_blob(self, owner: str, repo: str, content: str, encoding: str = \"utf-8\") -> str:\n        payload = {\"content\": content, \"encoding\": encoding}\n        r = requests.post(f\"{self.base_url}/repos/{owner}/{repo}/git/blobs\", headers=self._h(), json=payload, timeout=30)\n        r.raise_for_status()\n        return r.json()[\"sha\"]\n\n    def create_tree(self, owner: str, repo: str, base_tree: str, entries: List[Dict[str, Any]]) -> str:\n        payload = {\"base_tree\": base_tree, \"tree\": entries}\n        r = requests.post(f\"{self.base_url}/repos/{owner}/{repo}/git/trees\", headers=self._h(), json=payload, timeout=30)\n        r.raise_for_status()\n        return r.json()[\"sha\"]\n\n    def create_commit(self, owner: str, repo: str, message: str, tree_sha: str, parents: List[str]) -> str:\n        payload = {\"message\": message, \"tree\": tree_sha, \"parents\": parents}\n        r = requests.post(f\"{self.base_url}/repos/{owner}/{repo}/git/commits\", headers=self._h(), json=payload, timeout=30)\n        r.raise_for_status()\n        return r.json()[\"sha\"]\n\n    def update_ref(self, owner: str, repo: str, branch: str, new_sha: str) -> Dict[str, Any]:\n        payload = {\"sha\": new_sha, \"force\": False}\n        r = requests.patch(f\"{self.base_url}/repos/{owner}/{repo}/git/refs/heads/{branch}\", headers=self._h(), json=payload, timeout=30)\n        r.raise_for_status()\n        return r.json()\n\n    def compare_commits(self, owner: str, repo: str, base: str, head: str) -> Dict[str, Any]:\n        r = requests.get(\n            f\"{self.base_url}/repos/{owner}/{repo}/compare/{base}...{head}\",\n            headers=self._h(), timeout=60\n        )\n        r.raise_for_status()\n        return r.json()\n\n    def list_commits(self, owner: str, repo: str, sha: Optional[str] = None,\n                     path: Optional[str] = None, per_page: int = 100) -> List[Dict[str, Any]]:\n        params = {\"sha\": sha, \"path\": path, \"per_page\": per_page}\n        params = {k: v for k, v in params.items() if v is not None}\n        r = requests.get(\n            f\"{self.base_url}/repos/{owner}/{repo}/commits\",\n            headers=self._h(), params=params, timeout=60\n        )\n        r.raise_for_status()\n        return r.json()\n\n\n    def batch_commit(self, owner: str, repo: str, branch: str, message: str, changes: List[Dict[str, str]]) -> Dict[str, Any]:\n        \"\"\"\n        changes: [{ \"path\": \"dir/file.txt\", \"content\": \"string\", \"mode\": \"100644\" }]\n        \"\"\"\n        commit_sha, base_tree = self.get_commit_and_tree(owner, repo, branch)\n        tree_entries = []\n        for ch in changes:\n            blob_sha = self.create_blob(owner, repo, ch[\"content\"], \"utf-8\")\n            tree_entries.append({\n                \"path\": ch[\"path\"],\n                \"mode\": ch.get(\"mode\", \"100644\"),\n                \"type\": \"blob\",\n                \"sha\": blob_sha\n            })\n        new_tree = self.create_tree(owner, repo, base_tree, tree_entries)\n        new_commit = self.create_commit(owner, repo, message, new_tree, [commit_sha])\n        self.update_ref(owner, repo, branch, new_commit)\n        return {\"commit_sha\": new_commit}\n"
    },
    {
      "op": "write_file",
      "id": "update_main_py_validation",
      "description": "Add input validation and test-connection endpoint; validate before saving; fix branch autoloading",
      "path": "modular-framework/modules/github-hub/app/main.py",
      "mode": "overwrite",
      "content": "from __future__ import annotations\nimport os\nfrom typing import Optional, List, Dict, Any\nfrom fastapi import FastAPI, HTTPException, Query, Header\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import RedirectResponse\nfrom pydantic import BaseModel, Field\nfrom loguru import logger\nfrom pathlib import Path\n\nfrom .store import (\n    list_connections, get_connection, upsert_connection,\n    delete_connection, set_default, load_all, save_all\n)\nfrom .github_api import GHClient\n\napp = FastAPI(title=\"GitHub Hub\", version=\"0.4.0\")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"], allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"],\n)\n\napp.mount(\"/ui\", StaticFiles(directory=\"public\", html=True), name=\"ui\")\n\n# ----- helpers -----\n\ndef _client_for_conn(conn: Dict[str, Any]) -> GHClient:\n    tok = conn.get(\"token\")\n    if not tok:\n        token_file = os.getenv(\"GITHUB_TOKEN_FILE\")\n        if token_file and Path(token_file).exists():\n            tok = Path(token_file).read_text(encoding=\"utf-8\").strip()\n        tok = tok or os.getenv(\"GITHUB_TOKEN\")\n    if not tok:\n        raise HTTPException(400, \"No token available for this connection and no fallback provided.\")\n    base_url = conn.get(\"base_url\") or os.getenv(\"GITHUB_API_BASE\", \"https://api.github.com\")\n    return GHClient(token=tok, base_url=base_url)\n\ndef _client_for_input(token: Optional[str], base_url: Optional[str]) -> GHClient:\n    tok = token\n    if not tok:\n        token_file = os.getenv(\"GITHUB_TOKEN_FILE\")\n        if token_file and Path(token_file).exists():\n            tok = Path(token_file).read_text(encoding=\"utf-8\").strip()\n        tok = tok or os.getenv(\"GITHUB_TOKEN\")\n    if not tok:\n        raise HTTPException(400, \"Missing token: provide token or configure GITHUB_TOKEN[_FILE].\")\n    base = base_url or os.getenv(\"GITHUB_API_BASE\", \"https://api.github.com\")\n    return GHClient(token=tok, base_url=base)\n\n\ndef _owner_repo(conn: Dict[str, Any]) -> tuple[str, str]:\n    url = conn.get(\"repo_url\")\n    if not url:\n        raise HTTPException(400, \"Connection has no repo_url.\")\n    try:\n        return GHClient.parse_repo(url)\n    except ValueError as e:\n        raise HTTPException(400, str(e))\n\n\ndef _resolve_conn(conn_id: Optional[str], x_conn: Optional[str]) -> Dict[str, Any]:\n    cid = conn_id or x_conn\n    conn = get_connection(cid)\n    if not conn:\n        raise HTTPException(404, \"Connection not found (or default unset).\")\n    return conn\n\n# ----- models -----\nclass ConfigLegacyIn(BaseModel):\n    repo_url: str\n    default_branch: Optional[str] = \"main\"\n    base_url: Optional[str] = \"https://api.github.com\"\n    token: Optional[str] = None\n\nclass FilePut(BaseModel):\n    path: str\n    message: str\n    content: str\n    branch: Optional[str] = None\n    sha: Optional[str] = None\n\nclass BatchChange(BaseModel):\n    path: str\n    content: str\n    mode: Optional[str] = \"100644\"\n\nclass BatchCommit(BaseModel):\n    branch: str\n    message: str\n    changes: List[BatchChange]\n\nclass PullRequestIn(BaseModel):\n    title: str\n    head: str\n    base: str\n    body: Optional[str] = None\n    draft: Optional[bool] = False\n\nclass ConnectionIn(BaseModel):\n    id: str\n    repo_url: str\n    default_branch: Optional[str] = None\n    base_url: Optional[str] = \"https://api.github.com\"\n    name: Optional[str] = None\n    token: Optional[str] = None\n\nclass ConnectionTestIn(BaseModel):\n    repo_url: str\n    base_url: Optional[str] = \"https://api.github.com\"\n    token: Optional[str] = None\n\n# ----- validation utilities -----\n\ndef _validate_connection_inputs(repo_url: str, base_url: Optional[str]) -> None:\n    # parse_repo will further validate path\n    try:\n        GHClient.parse_repo(repo_url)\n    except ValueError as e:\n        raise HTTPException(400, f\"Invalid repo_url: {e}\")\n    if base_url:\n        base_url = base_url.strip()\n        if not (base_url.startswith(\"http://\") or base_url.startswith(\"https://\")):\n            raise HTTPException(400, \"base_url must start with http:// or https://\")\n\n\ndef _default_branch_from(branches: List[str]) -> str:\n    if not branches:\n        return \"main\"\n    if \"main\" in branches:\n        return \"main\"\n    if \"master\" in branches:\n        return \"master\"\n    return branches[0]\n\n# ----- basic -----\n@app.get(\"/\")\ndef root():\n    return RedirectResponse(url=\"/ui/\")\n\n@app.get(\"/api/health\")\ndef health():\n    st = load_all()\n    return {\"status\": \"ok\", \"default_id\": st.get(\"default_id\"), \"connections\": [c[\"id\"] for c in st.get(\"connections\", [])]}\n\n# ----- connection management -----\n@app.get(\"/api/connections\")\ndef api_list_conns():\n    st = load_all()\n    return {\"default_id\": st.get(\"default_id\"), \"connections\": list_connections(redact=True)}\n\n@app.post(\"/api/connections/validate\")\ndef api_validate_conn(body: ConnectionTestIn):\n    _validate_connection_inputs(body.repo_url, body.base_url)\n    client = _client_for_input(body.token, body.base_url)\n    try:\n        owner, repo = GHClient.parse_repo(body.repo_url)\n        branches = client.get_branches(owner, repo)\n        return {\"ok\": True, \"branches\": branches, \"default_branch\": _default_branch_from(branches)}\n    except Exception as e:\n        logger.exception(\"Connection validation failed\")\n        raise HTTPException(400, f\"Validation failed: {e}\")\n\n@app.post(\"/api/connections\")\ndef api_upsert_conn(body: ConnectionIn):\n    # Validate inputs\n    _validate_connection_inputs(body.repo_url, body.base_url)\n    # Validate against GitHub first (do not save yet)\n    try:\n        client = _client_for_input(body.token, body.base_url)\n        owner, repo = GHClient.parse_repo(body.repo_url)\n        branches = client.get_branches(owner, repo)\n    except Exception as e:\n        logger.exception(\"connection validation failed\")\n        raise HTTPException(400, f\"Validation failed: {e}\")\n\n    # Save (with branches) only after validation\n    try:\n        upsert_payload = body.model_dump(exclude_unset=True)\n        # set default_branch if not provided\n        if not upsert_payload.get(\"default_branch\"):\n            upsert_payload[\"default_branch\"] = _default_branch_from(branches)\n        # Attach token if provided (store will encrypt if configured)\n        c = upsert_connection(upsert_payload)\n        # persist branches back\n        st = load_all()\n        for cc in st[\"connections\"]:\n            if cc[\"id\"] == c[\"id\"]:\n                cc[\"branches\"] = branches\n        save_all(st)\n        return {\"ok\": True, \"id\": c[\"id\"], \"branches\": branches, \"default_branch\": upsert_payload[\"default_branch\"]}\n    except Exception as e:\n        logger.exception(\"failed to save connection\")\n        raise HTTPException(500, f\"Failed to save connection: {e}\")\n\n@app.delete(\"/api/connections/{conn_id}\")\ndef api_delete_conn(conn_id: str):\n    delete_connection(conn_id)\n    return {\"ok\": True}\n\n@app.post(\"/api/connections/{conn_id}/default\")\ndef api_set_default(conn_id: str):\n    set_default(conn_id)\n    return {\"ok\": True, \"default_id\": conn_id}\n\n@app.put(\"/api/connections/{conn_id}/default\")\ndef api_set_default_put(conn_id: str):\n    return api_set_default(conn_id)\n\n@app.get(\"/api/connections/{conn_id}/health\")\ndef api_conn_health(conn_id: str):\n    conn = _resolve_conn(conn_id, None)\n    gh = _client_for_conn(conn)\n    owner, repo = _owner_repo(conn)\n    try:\n        branches = gh.get_branches(owner, repo)\n        # Optionally refresh stored branches\n        st = load_all()\n        for cc in st.get(\"connections\", []):\n            if cc.get(\"id\") == conn_id:\n                cc[\"branches\"] = branches\n        save_all(st)\n        return {\"ok\": True, \"branches\": branches}\n    except Exception as e:\n        raise HTTPException(502, f\"GitHub failed: {e}\")\n\n# ----- legacy ‚Äúconfig‚Äù view (now shows multi-conn) -----\n@app.get(\"/api/config\")\ndef get_cfg():\n    st = load_all()\n    return {\"default_id\": st.get(\"default_id\"), \"connections\": list_connections(redact=True)}\n\n@app.post(\"/api/config\")\ndef legacy_set_cfg(body: ConfigLegacyIn):\n    # Validate first\n    _validate_connection_inputs(body.repo_url, body.base_url)\n    client = _client_for_input(body.token, body.base_url)\n    owner, repo = GHClient.parse_repo(body.repo_url)\n    branches = client.get_branches(owner, repo)\n\n    # Upsert a ‚Äúdefault‚Äù connection and set it default\n    data = {\n        \"id\": \"default\",\n        \"repo_url\": body.repo_url,\n        \"default_branch\": body.default_branch or _default_branch_from(branches),\n        \"base_url\": body.base_url,\n    }\n    if body.token:\n        data[\"token\"] = body.token\n    c = upsert_connection(data)\n    set_default(\"default\")\n    # persist branches\n    st = load_all()\n    for cc in st[\"connections\"]:\n        if cc[\"id\"] == \"default\":\n            cc[\"branches\"] = branches\n    save_all(st)\n    return {\"ok\": True, \"branches\": branches, \"default_id\": \"default\"}\n\n# ----- GitHub operations (conn-aware) -----\n@app.get(\"/api/branches\")\ndef branches(\n    conn_id: Optional[str] = Query(None),\n    x_conn: Optional[str] = Header(None, alias=\"X-GH-Conn\"),\n):\n    conn = _resolve_conn(conn_id, x_conn)\n    gh = _client_for_conn(conn)\n    owner, repo = _owner_repo(conn)\n    return {\"branches\": gh.get_branches(owner, repo)}\n\n@app.post(\"/api/branch\")\ndef create_branch(\n    new: str = Query(..., alias=\"new\"),\n    base: str = Query(..., alias=\"from\"),\n    conn_id: Optional[str] = Query(None),\n    x_conn: Optional[str] = Header(None, alias=\"X-GH-Conn\"),\n):\n    conn = _resolve_conn(conn_id, x_conn)\n    gh = _client_for_conn(conn); owner, repo = _owner_repo(conn)\n    return gh.create_branch(owner, repo, new, base)\n\n@app.get(\"/api/tree\")\ndef tree(\n    path: Optional[str] = None,\n    branch: Optional[str] = None,\n    recursive: bool = True,\n    conn_id: Optional[str] = Query(None),\n    x_conn: Optional[str] = Header(None, alias=\"X-GH-Conn\"),\n):\n    conn = _resolve_conn(conn_id, x_conn)\n    gh = _client_for_conn(conn); owner, repo = _owner_repo(conn)\n    b = branch or conn.get(\"default_branch\") or \"main\"\n    t = gh.get_tree(owner, repo, b, recursive=bool(recursive))\n    items = t.get(\"tree\", [])\n    if path:\n        prefix = path.strip().rstrip(\"/\") + \"/\"\n        items = [i for i in items if i[\"path\"].startswith(prefix)]\n    return {\"branch\": b, \"items\": items}\n\n@app.get(\"/api/file\")\ndef get_file(\n    path: str,\n    branch: Optional[str] = None,\n    conn_id: Optional[str] = Query(None),\n    x_conn: Optional[str] = Header(None, alias=\"X-GH-Conn\"),\n):\n    conn = _resolve_conn(conn_id, x_conn)\n    gh = _client_for_conn(conn); owner, repo = _owner_repo(conn)\n    ref = branch or conn.get(\"default_branch\") or \"main\"\n    return gh.get_file(owner, repo, path, ref=ref)\n\n@app.put(\"/api/file\")\ndef put_file(\n    body: FilePut,\n    conn_id: Optional[str] = Query(None),\n    x_conn: Optional[str] = Header(None, alias=\"X-GH-Conn\"),\n):\n    conn = _resolve_conn(conn_id, x_conn)\n    gh = _client_for_conn(conn); owner, repo = _owner_repo(conn)\n    b = body.branch or conn.get(\"default_branch\") or \"main\"\n    return gh.put_file(owner, repo, body.path, body.message, body.content, b, body.sha)\n\n@app.delete(\"/api/file\")\ndef delete_file(\n    path: str, message: str, sha: str, branch: Optional[str] = None,\n    conn_id: Optional[str] = Query(None),\n    x_conn: Optional[str] = Header(None, alias=\"X-GH-Conn\"),\n):\n    conn = _resolve_conn(conn_id, x_conn)\n    gh = _client_for_conn(conn); owner, repo = _owner_repo(conn)\n    b = branch or conn.get(\"default_branch\") or \"main\"\n    return gh.delete_file(owner, repo, path, message, sha, b)\n\n@app.post(\"/api/batch/commit\")\ndef batch_commit(\n    body: BatchCommit,\n    conn_id: Optional[str] = Query(None),\n    x_conn: Optional[str] = Header(None, alias=\"X-GH-Conn\"),\n):\n    conn = _resolve_conn(conn_id, x_conn)\n    gh = _client_for_conn(conn); owner, repo = _owner_repo(conn)\n    changes = [c.model_dump() for c in body.changes]\n    return gh.batch_commit(owner, repo, body.branch, body.message, changes)\n\n@app.post(\"/api/pr\")\ndef create_pr(\n    body: PullRequestIn,\n    conn_id: Optional[str] = Query(None),\n    x_conn: Optional[str] = Header(None, alias=\"X-GH-Conn\"),\n):\n    conn = _resolve_conn(conn_id, x_conn)\n    gh = _client_for_conn(conn); owner, repo = _owner_repo(conn)\n    try:\n        pr = gh.create_pull_request(owner, repo, body.title, body.head, body.base, body.body, body.draft or False)\n        return {\"ok\": True, \"pull_request\": pr}\n    except Exception as e:\n        logger.exception(\"Failed to create PR\")\n        raise HTTPException(400, f\"PR creation failed: {e}\")\n\n# ---- Nice-to-have ‚Äúgit basics‚Äù via GitHub API ----\n@app.get(\"/api/compare\")\ndef compare(\n    base: str, head: str,\n    conn_id: Optional[str] = Query(None),\n    x_conn: Optional[str] = Header(None, alias=\"X-GH-Conn\"),\n):\n    conn = _resolve_conn(conn_id, x_conn)\n    gh = _client_for_conn(conn); owner, repo = _owner_repo(conn)\n    return gh.compare_commits(owner, repo, base, head)\n\n@app.get(\"/api/commits\")\ndef list_commits(\n    sha: Optional[str] = None, path: Optional[str] = None, per_page: int = 100,\n    conn_id: Optional[str] = Query(None),\n    x_conn: Optional[str] = Header(None, alias=\"X-GH-Conn\"),\n):\n    conn = _resolve_conn(conn_id, x_conn)\n    gh = _client_for_conn(conn); owner, repo = _owner_repo(conn)\n    return gh.list_commits(owner, repo, sha=sha, path=path, per_page=per_page)\n"
    },
    {
      "op": "write_file",
      "id": "update_github_hub_index_html",
      "description": "Improve GitHub Hub UI modal (remove duplicate form), add Test buttons, small UX tweaks",
      "path": "modular-framework/modules/github-hub/public/index.html",
      "mode": "overwrite",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\"/>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n  <link rel=\"icon\" href=\"data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'/>\">\n  <title>GitHub Hub</title>\n  <link rel=\"stylesheet\" href=\"./css/theme.css\"/>\n  <style>\n    :root { --indent: 14px; }\n\n    .wrap{display:grid;grid-template-columns:320px 1fr;gap:12px;height:100vh}\n    .side{border-right:1px solid var(--line);padding:12px;overflow:auto}\n    .main{padding:12px;overflow:auto}\n    .file-view{\n      white-space:pre; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;\n      border:1px solid var(--line); border-radius:6px; padding:10px; background:#111; min-height:200px\n    }\n    .muted{color:var(--muted); font-size:12px}\n\n    /* SIDE MODE (embed=side) */\n    .embed-side .header { display:none; }\n    .embed-side .wrap { grid-template-columns: 1fr; height: 100vh; }\n    .embed-side .side { border-right: none; padding: 8px; }\n    .embed-side .main { display: none; }\n\n    /* Tree */\n    .tree { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px }\n    .tree > ul { list-style:none; margin:0; padding-left:0; }\n    .tree ul ul { list-style:none; margin:0; padding-left: var(--indent); }\n    .tree li { margin:0; }\n    .tree .row {\n      display:grid;\n      grid-template-columns: 1em 1.1em 1.1em 1fr; /* twisty | checkbox | icon | name */\n      align-items:center;\n      gap:6px;\n      padding:3px 6px;\n      border-radius:6px;\n    }\n    .tree .row:hover { background:#222; }\n    .tree .twisty { text-align:center; cursor:pointer; user-select:none; }\n    .tree .icon { text-align:center; }\n    .tree .name { cursor:pointer; }\n\n    .tree .dir.collapsed > ul { display:none; }\n    .tree .dir.collapsed > .row .twisty::before { content: \"‚ñ∏\"; }\n    .tree .dir.open      > .row .twisty::before { content: \"‚ñæ\"; }\n\n    /* Small toolbar above the tree */\n    .tree-tools { display:flex; gap:6px; margin:6px 0 8px; align-items:center; }\n    .chip { font-size:11px; color:#bbb; padding:2px 6px; border:1px solid #333; border-radius:999px; }\n    button.ghost{background:#2a2c31}\n  </style>\n  <script>\n    (function () {\n      const params = new URLSearchParams(location.search);\n      if ((params.get('embed')||'').toLowerCase() === 'side') {\n        document.documentElement.classList.add('embed-side');\n      }\n    })();\n  </script>\n</head>\n<body>\n  <div class=\"header\"><strong>GitHub Hub</strong><div class=\"grow\"></div><span class=\"muted\">API helper for the whole framework</span></div>\n\n  <div class=\"wrap\">\n    <div class=\"side\">\n      <h3>Repository</h3>\n      <div class=\"connbar\">\n        <select id=\"connSelect\" title=\"Active connection\"></select>\n        <button class=\"ghost\" id=\"manageConnsBtn\" title=\"Manage connections\">Manage</button>\n        <div class=\"grow\"></div>\n        <button class=\"ghost\" id=\"openPrBtn\" title=\"Create Pull Request\">New PR</button>\n      </div>\n      <input type=\"search\" id=\"filterInput\" placeholder=\"Filter files (glob or /regex/)\" />\n      <label>Repo URL</label>\n      <input id=\"repoUrl\" placeholder=\"https://github.com/owner/repo\" />\n      <label>Branch</label>\n      <select id=\"branchSelect\"></select>\n      <div class=\"row\">\n        <button id=\"saveCfgBtn\">Save</button>\n        <button class=\"ghost\" id=\"testCfgBtn\" title=\"Test connection without saving\">Test</button>\n        <button class=\"ghost\" id=\"reloadBtn\">Reload</button>\n      </div>\n      <details>\n        <summary class=\"muted\">Advanced</summary>\n        <label>Base API URL</label>\n        <input id=\"baseUrl\" placeholder=\"https://api.github.com\" />\n        <label>PAT (repo scope)</label>\n        <input id=\"token\" placeholder=\"ghp_...\" />\n      </details>\n      <div class=\"row\" id=\"copyTools\" style=\"margin-top:10px\">\n        <button id=\"copyBtn\" class=\"ghost\" title=\"Concatenate selected files and copy\">Copy to clipboard</button>\n        <span class=\"chip\" id=\"tokenCountChip\">0 tokens</span>\n      </div>\n      <div class=\"tree-tools\">\n        <button class=\"ghost\" id=\"expandAllBtn\">Expand all</button>\n        <button class=\"ghost\" id=\"collapseAllBtn\">Collapse all</button>\n        <span class=\"chip\" id=\"selCountChip\">0 selected</span>\n      </div>\n      <div id=\"tree\" class=\"tree\"></div>\n    </div>\n    <div class=\"main\">\n      <h3>Selected File</h3>\n      <div id=\"fileMeta\" class=\"muted\"></div>\n      <pre id=\"fileView\" class=\"file-view\">(select a file)</pre>\n      <div class=\"row\">\n        <input id=\"commitMsg\" placeholder=\"Commit message\" />\n        <button id=\"saveFileBtn\">Save file</button>\n      </div>\n    </div>\n  </div>\n<div id=\"connModal\" class=\"modal\">\n  <div class=\"box\">\n    <h3>Connections</h3>\n    <h4 style=\"margin:6px 0 8px\">Add / Edit</h4>\n      <div class=\"grid2\">\n        <div>\n          <label>ID</label><input id=\"mId\" placeholder=\"owner-repo or any slug\" />\n          <label>Name (display)</label><input id=\"mName\" placeholder=\"My Repo\" />\n          <label>Repo URL</label><input id=\"mRepo\" placeholder=\"https://github.com/owner/repo\" />\n          <label>Default Branch</label><input id=\"mBranch\" value=\"main\" />\n        </div>\n        <div>\n          <label>Base API URL</label><input id=\"mBase\" placeholder=\"https://api.github.com\" />\n          <label>Token (PAT)</label><input id=\"mTok\" placeholder=\"ghp_...\" />\n        </div>\n      </div>\n    <div id=\"connList\" class=\"muted\" style=\"margin:6px 0 10px\">Loading‚Ä¶</div>\n    <hr/>\n\n    <div class=\"row\">\n      <button id=\"saveConnBtn\">Save</button>\n      <button class=\"ghost\" id=\"testConnModalBtn\">Test</button>\n      <button class=\"ghost\" id=\"closeConnBtn\">Close</button>\n    </div>\n    <small class=\"muted\">Tokens are stored encrypted if a key is configured on the server.</small>\n  </div>\n</div>\n\n<div id=\"prModal\" class=\"modal\">\n  <div class=\"box\">\n    <h3>New Pull Request</h3>\n    <div class=\"grid2\">\n      <div>\n        <label>Title</label><input id=\"prTitle\" />\n        <label>Base (target)</label><input id=\"prBase\" placeholder=\"main\" />\n      </div>\n      <div>\n        <label>Head (source)</label><input id=\"prHead\" placeholder=\"feature/my-change\" />\n        <label>Draft?</label>\n        <select id=\"prDraft\"><option value=\"false\">No</option><option value=\"true\">Yes</option></select>\n      </div>\n    </div>\n    <label>Body (markdown)</label>\n    <textarea id=\"prBody\" rows=\"6\"></textarea>\n    <div class=\"row\">\n      <button id=\"createPrBtn\">Create PR</button>\n      <button class=\"ghost\" id=\"closePrBtn\">Close</button>\n    </div>\n  </div>\n</div>\n\n<div id=\"toast\" class=\"toast\"></div>\n<script type=\"module\" src=\"./js/app.js\"></script>\n</body>\n</html>\n"
    },
    {
      "op": "write_file",
      "id": "update_github_hub_app_js",
      "description": "Add frontend input validation and test-connection flows (before saving); improve branches loading fallback",
      "path": "modular-framework/modules/github-hub/public/js/app.js",
      "mode": "overwrite",
      "content": "const $ = (id)=>document.getElementById(id);\nconst isSide = new URLSearchParams(location.search).get('embed') === 'side';\n\n// Figure out the module base (works standalone and when proxied)\nconst API = (() => {\n  const p = location.pathname;\n  const idx = p.indexOf('/ui/');\n  if (idx !== -1) return p.slice(0, idx) + '/api';\n  const m = p.match(/^(.*?\\/api\\/v1\\/github)(?:\\/|$)/);\n  if (m) return `${m[1]}/api`;\n  return '/api';\n})();\n\n// --- file-content cache (per branch:path) ---\nconst fileCache = new Map();\n\n/** Robust tokenizer loader with local+CDN fallback and safe approximation */\nlet _encPromise = null;\nlet HAS_MULTI = false;\nlet EDITING_CONN = null;\n\nfunction slugify(s){\n  return (s||'').toLowerCase()\n    .replace(/https?:\\/\\/github\\.com\\//,'')\n    .replace(/[^a-z0-9\\-_.]+/g,'-')\n    .replace(/-+/g,'-')\n    .replace(/^-|-$/g,'');\n}\n\nfunction isHttpUrl(u){\n  return typeof u === 'string' && (u.startsWith('http://') || u.startsWith('https://'));\n}\n\nfunction looksLikeRepoUrl(u){\n  if (!u || typeof u !== 'string') return false;\n  const s = u.trim();\n  if (s.startsWith('git@') && s.includes(':')) return true;\n  if (isHttpUrl(s) && s.split('/').filter(Boolean).length >= 4) return true; // scheme + host + owner + repo\n  return false;\n}\n\nfunction validateConnInput({ id, repo_url, base_url, token }){\n  const errs = [];\n  if (id && !/^[a-z0-9._\\-]{1,128}$/.test(id)) errs.push('ID must be a slug (lowercase letters, numbers, . _ -)');\n  if (!looksLikeRepoUrl(repo_url)) errs.push('Repo URL must be https://.../owner/repo or git@host:owner/repo');\n  if (base_url && !isHttpUrl(base_url)) errs.push('Base API URL must start with http:// or https://');\n  if (token && token.length < 20) errs.push('Token looks too short');\n  return errs;\n}\n\nasync function testConnectionPayload(payload){\n  const res = await api('/connections/validate', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ repo_url: payload.repo_url, base_url: payload.base_url, token: payload.token || undefined })\n  });\n  return res;\n}\n\nasync function getEncoder() {\n  if (!_encPromise) {\n    _encPromise = (async () => {\n      try {\n        const { Tiktoken } = await import('https://cdn.jsdelivr.net/npm/js-tiktoken@1.0.21/lite.js');\n        let ranksRes;\n        try {\n          ranksRes = await fetch('./js/tiktoken/o200k_base.json', { cache: 'force-cache' });\n          if (!ranksRes.ok) throw new Error('local ranks missing');\n        } catch {\n          ranksRes = await fetch('https://tiktoken.pages.dev/js/o200k_base.json', { cache: 'force-cache' });\n        }\n        const ranks = await ranksRes.json();\n        return new Tiktoken(ranks);\n      } catch (e) {\n        console.warn('[github-hub] Tokenizer unavailable, using approximation:', e);\n        return null;\n      }\n    })();\n  }\n  return _encPromise;\n}\n\nasync function countTokensFor(text) {\n  const enc = await getEncoder();\n  if (enc) {\n    try { return enc.encode(text).length; }\n    catch (e) { console.warn('[github-hub] encode failed, approx fallback:', e); }\n  }\n  return Math.ceil(text.length / 4);\n}\n\n/** Fetch file content (cached per branch+path) */\nasync function getFileContent(path, branch) {\n  const key = `${branch}:${path}`;\n  if (fileCache.has(key)) return fileCache.get(key);\n  const data = await api(`/file?path=${encodeURIComponent(path)}&branch=${encodeURIComponent(branch)}`);\n  const content = data.decoded_content || '';\n  fileCache.set(key, content);\n  return content;\n}\n\n/** Build clipboard text with a header line BEFORE EACH file */\nasync function buildClipboardText(paths, branch) {\n  const parts = [];\n  for (const p of paths) {\n    const name = p.split('/').pop() || p;\n    parts.push(`# ${p}\\n`);\n    const content = await getFileContent(p, branch);\n    parts.push(content.endsWith('\\n') ? content : content + '\\n');\n    parts.push('\\n');\n  }\n  return parts.join('');\n}\n\nlet ACTIVE_CONN = null;   // current connection id (null => default)\nconst endpointProbeCache = new Map();\n\nasync function hasEndpoint(path) {\n  if (endpointProbeCache.has(path)) return endpointProbeCache.get(path);\n  try {\n    const r = await fetch(`${API}${path}`, { method: 'OPTIONS' });\n    const ok = r.ok || (r.status >= 200 && r.status < 400);\n    endpointProbeCache.set(path, ok);\n    return ok;\n  } catch {\n    endpointProbeCache.set(path, false);\n    return false;\n  }\n}\n\nasync function api(path, init) {\n  const url = new URL(`${API}${path}`, location.origin);\n  if (ACTIVE_CONN && !url.searchParams.has('conn_id')) {\n    url.searchParams.set('conn_id', ACTIVE_CONN);\n  }\n  const headers = { ...(init?.headers || {}), 'X-Requested-With': 'github-hub' };\n  if (ACTIVE_CONN) headers['X-GH-Conn'] = ACTIVE_CONN;\n\n  const res = await fetch(url.toString(), { ...init, headers });\n  if (!res.ok) {\n    let errText = '';\n    try { errText = await res.text(); } catch {}\n    throw new Error(errText || `HTTP ${res.status}`);\n  }\n  return res.json();\n}\n\nasync function loadConnections() {\n  const sel = $('connSelect');\n  const manageBtn = $('manageConnsBtn');\n\n  let multi = false;\n  try {\n    const r = await api('/connections');\n    const conns = r.connections || [];\n    const def = r.default_id || r.defaultId || null;\n\n    sel.innerHTML = '';\n    conns.forEach(c => {\n      const o = new Option(c.name || c.id || c.repo_url, c.id);\n      sel.appendChild(o);\n    });\n    ACTIVE_CONN = def || conns[0]?.id || null;\n    if (ACTIVE_CONN) sel.value = ACTIVE_CONN;\n\n    manageBtn.disabled = false;\n    HAS_MULTI = true;\n    const active = conns.find(c => c.id === (ACTIVE_CONN || def)) || conns[0];\n    if (active) {\n      $('repoUrl').value = (active.repo_url || '').replace(/\\/+$/,'');\n      $('baseUrl').value = active.base_url || 'https://api.github.com';\n    }\n    multi = true;\n  } catch {\n    const c = await api('/config');\n    sel.innerHTML = '';\n    const o = new Option((c.repo_url || 'Default').replace(/\\/+$/,''), 'default');\n    sel.appendChild(o);\n    ACTIVE_CONN = null;\n    sel.value = 'default';\n    manageBtn.disabled = true;\n    HAS_MULTI = false;\n  }\n  if (!multi) manageBtn.classList.add('hidden'); else manageBtn.classList.remove('hidden');\n}\n\nfunction toast(msg, ok = true) {\n  const t = $('toast'); if (!t) { alert(msg); return; }\n  t.textContent = msg;\n  t.style.borderColor = ok ? '#2d7d46' : '#a1260d';\n  t.classList.add('show');\n  setTimeout(()=> t.classList.remove('show'), 2000);\n}\n\nfunction openModal(id){ $(id)?.classList.add('show'); }\nfunction closeModal(id){ $(id)?.classList.remove('show'); }\n\nasync function openConnManager() {\n  try {\n    const r = await api('/connections');\n    const list = r.connections || [];\n    const def = r.default_id || r.defaultId;\n    const box = $('connList');\n    if (!box) return;\n\n    if (!list.length) {\n      box.innerHTML = '<div class=\"muted\">No connections yet.</div>';\n      return;\n    }\n\n    box.innerHTML = list.map(c => {\n      const isDef = c.id === def;\n      const bcount = (c.branches || []).length;\n      return `\n        <div class=\"item\" style=\"display:flex;gap:8px;align-items:center;justify-content:space-between;border:1px solid var(--line);border-radius:6px;padding:6px 8px;margin:6px 0\">\n          <div>\n            <strong>${c.name || c.id}</strong>\n            <div class=\"muted\">${(c.repo_url||'').replace(/\\/+$/,'')} ‚Ä¢ ${c.default_branch || 'main'} ‚Ä¢ ${bcount} branches</div>\n          </div>\n          <div>\n            <button class=\"ghost\" data-default=\"${c.id}\" ${isDef?'disabled':''}>${isDef?'Default':'Make default'}</button>\n            <button class=\"ghost\" data-edit=\"${c.id}\">Edit</button>\n            <button class=\"danger\" data-del=\"${c.id}\">Delete</button>\n          </div>\n        </div>`;\n    }).join('');\n\n    box.querySelectorAll('button[data-default]')?.forEach(b => b.onclick = async () => {\n      const id = b.getAttribute('data-default');\n      try { await api(`/connections/${encodeURIComponent(id)}/default`, { method:'POST' }); await api(`/connections/${encodeURIComponent(id)}/default`, { method:'PUT' }); toast('Default updated'); await loadConnections(); await openConnManager(); } catch(e){ toast(e.message,false); }\n    });\n    box.querySelectorAll('button[data-del]')?.forEach(b => b.onclick = async () => {\n      const id = b.getAttribute('data-del');\n      if (!confirm('Delete connection?')) return;\n      try { await api(`/connections/${encodeURIComponent(id)}`, { method:'DELETE' }); toast('Deleted'); await loadConnections(); await openConnManager(); } catch(e){ toast(e.message,false); }\n    });\n    box.querySelectorAll('button[data-edit]')?.forEach(b => b.onclick = async () => {\n      const id = b.getAttribute('data-edit');\n      const c = (r.connections||[]).find(x => x.id === id);\n      if (!c) return;\n      EDITING_CONN = id;\n      $('mId').value = c.id || '';\n      $('mName').value = c.name || '';\n      $('mRepo').value = c.repo_url || '';\n      $('mBranch').value = c.default_branch || 'main';\n      $('mBase').value = c.base_url || 'https://api.github.com';\n      $('mTok').value = '';\n    });\n\n    openModal('connModal');\n  } catch {\n    toast('Multi-connection API not available', false);\n  }\n}\n\nexport async function loadConfig(){\n  try{\n    const c = await api('/config');\n    $('repoUrl').value = c.repo_url || '';\n    $('baseUrl').value = c.base_url || 'https://api.github.com';\n  }catch(e){ console.warn(e); }\n}\n\nasync function testCurrentConfig(){\n  const payload = {\n    repo_url: $('repoUrl').value.trim(),\n    base_url: $('baseUrl').value.trim() || 'https://api.github.com',\n    token: $('token').value.trim() || undefined\n  };\n  const errs = validateConnInput({ id: 'tmp', ...payload });\n  if (errs.length) { toast(errs[0], false); return; }\n  try {\n    const res = await testConnectionPayload(payload);\n    toast(`OK ‚Ä¢ ${res.branches?.length || 0} branches`);\n    await loadBranches(res.branches);\n  } catch (e) {\n    toast(e.message, false);\n  }\n}\n\nexport async function saveConfig(){\n  const repo_url = $('repoUrl').value.trim();\n  const default_branch = $('branchSelect').value || '';\n  const base_url = $('baseUrl').value.trim() || 'https://api.github.com';\n  const token = $('token').value.trim();\n\n  const id = HAS_MULTI ? (ACTIVE_CONN || slugify(repo_url) || 'default') : 'default';\n  const payload = { id, repo_url, default_branch: default_branch || undefined, base_url, token: token || undefined };\n  const errs = validateConnInput(payload);\n  if (errs.length) { toast(errs[0], false); return; }\n\n  // Test before saving\n  try {\n    const testRes = await testConnectionPayload({ repo_url, base_url, token });\n    if (!payload.default_branch) payload.default_branch = testRes.default_branch || 'main';\n  } catch (e) {\n    toast(`Validation failed: ${e.message}`, false);\n    return;\n  }\n\n  if (HAS_MULTI) {\n    await api('/connections', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });\n    toast('Connection saved');\n    $('token').value = '';\n    await loadConnections();\n  } else {\n    await api('/config', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ repo_url, default_branch: payload.default_branch, base_url, token: token || undefined }) });\n  }\n  await loadBranches();\n  await loadTree();\n}\n\nexport async function loadBranches(prefetched = null){\n  const sel = $('branchSelect');\n  sel.innerHTML = '';\n  try{\n    const b = prefetched ? { branches: prefetched } : await api('/branches');\n    const names = Array.from(new Set((b.branches||[])));\n    if (!names.length) throw new Error('No branches');\n    names.forEach(name=>{\n      const o = document.createElement('option');\n      o.value = o.textContent = name;\n      sel.appendChild(o);\n    });\n  }catch(e){\n    ['main','master'].forEach(n=>{\n      const o = document.createElement('option');\n      o.value = o.textContent = n;\n      sel.appendChild(o);\n    });\n  }\n}\n\nlet currentFile = null;\nlet currentSha  = null;\n\nexport async function openFile(path){\n  const branch = $('branchSelect').value || 'main';\n  const data = await api(`/file?path=${encodeURIComponent(path)}&branch=${encodeURIComponent(branch)}`);\n  currentFile = path;\n  currentSha  = data.sha;\n  $('fileMeta').textContent = `${path} @ ${branch} (sha ${data.sha?.slice(0,7)})`;\n  $('fileView').textContent = data.decoded_content || '';\n}\n\nexport async function saveFile(){\n  if (!currentFile) return alert('No file open');\n  const branch = $('branchSelect').value || 'main';\n  const message = $('commitMsg').value.trim() || `Update ${currentFile}`;\n  const content = $('fileView').textContent;\n  const payload = { path: currentFile, message, content, branch, sha: currentSha };\n  const res = await api('/file', { method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });\n  alert(`Committed ${currentFile}\\n${res.commit?.sha || res.content?.sha || ''}`);\n  await loadTree();\n  await openFile(currentFile);\n}\n\nfunction matchFilter(path, value) {\n  if (!value) return true;\n  const v = value.trim();\n  if (v.startsWith('/') && v.endsWith('/') && v.length > 2) {\n    try { return new RegExp(v.slice(1,-1), 'i').test(path); }\n    catch { return true; }\n  }\n  return path.toLowerCase().includes(v.toLowerCase());\n}\n\nfunction applyFilter(){\n  const treeEl = $('tree'); const q = $('filterInput')?.value || '';\n  if (!treeEl) return;\n  treeEl.querySelectorAll('li.file').forEach(li=>{\n    const p = li.dataset.path || '';\n    li.style.display = matchFilter(p, q) ? '' : 'none';\n  });\n  treeEl.querySelectorAll('li.dir').forEach(li=>{\n    const hasVisible = li.querySelector(':scope li.file:not([style*=\"display: none\"])') ||\n                       li.querySelector(':scope li.dir:not([style*=\"display: none\"])');\n    li.style.display = hasVisible ? '' : 'none';\n  });\n}\n\nasync function createPR(){\n  const title = $('prTitle').value.trim();\n  const head  = $('prHead').value.trim();\n  const base  = $('prBase').value.trim() || 'main';\n  const body  = $('prBody').value;\n  const draft = $('prDraft').value === 'true';\n\n  if (!title || !head) { toast('Title and head are required', false); return; }\n\n  try{\n    const res = await api('/pr', {\n      method:'POST',\n      headers:{'Content-Type':'application/json'},\n      body: JSON.stringify({ title, head, base, body, draft })\n    });\n    const url = res?.pull_request?.html_url || '';\n    toast('PR created');\n    closeModal('prModal');\n    if (url) window.open(url, '_blank');\n  }catch(e){\n    toast(`PR failed: ${e.message}`, false);\n  }\n}\n\n// -------- Tree (collapsed by default, folder-select selects all descendants) ----------\nexport async function loadTree(){\n  const treeEl = $('tree');\n  treeEl.innerHTML = '<div class=\"muted\">Loading‚Ä¶</div>';\n\n  try{\n    const branch = $('branchSelect').value || 'main';\n    const t = await api(`/tree?branch=${encodeURIComponent(branch)}&recursive=true`);\n    const items = (t.items||[]).filter(i => i.type==='blob' || i.type==='tree');\n\n    function makeNode(name, type, fullPath){\n      return { name, type, path: fullPath, children: new Map() };\n    }\n    const root = makeNode('', 'tree', '');\n\n    for (const i of items) {\n      const parts = i.path.split('/');\n      let cur = root;\n      for (let p = 0; p < parts.length; p++){\n        const seg = parts[p];\n        const isLast = p === parts.length - 1;\n        const nodeType = isLast ? i.type : 'tree';\n        const childPath = parts.slice(0, p+1).join('/');\n        if (!cur.children.has(seg)) cur.children.set(seg, makeNode(seg, nodeType, childPath));\n        cur = cur.children.get(seg);\n      }\n    }\n\n    function renderNode(node){\n      if (node.type === 'blob') {\n        const li = document.createElement('li');\n        li.className = 'file';\n        li.dataset.path = node.path;\n        li.innerHTML = `\n          <div class=\"row\">\n            <span class=\"twisty\"></span>\n            <input type=\"checkbox\" class=\"sel\" data-path=\"${node.path}\" />\n            <span class=\"icon\">üìÑ</span>\n            <a href=\"#\" data-file=\"${node.path}\" class=\"name\">${node.name}</a>\n          </div>`;\n        return li;\n      } else {\n        const li = document.createElement('li');\n        li.className = 'dir collapsed';\n        li.dataset.path = node.path;\n        const label = node.name || '';\n        li.innerHTML = `\n          <div class=\"row\">\n            <span class=\"twisty\"></span>\n            <input type=\"checkbox\" class=\"sel\" data-path=\"${node.path}\" />\n            <span class=\"icon\">üìÅ</span>\n            <span class=\"name\">${label}</span>\n          </div>\n          <ul class=\"children\"></ul>`;\n        const ul = li.querySelector('.children');\n\n        const children = Array.from(node.children.values())\n          .sort((a,b)=>{\n            if (a.type!==b.type) return a.type==='tree' ? -1 : 1;\n            return a.name.localeCompare(b.name);\n          });\n\n        for (const c of children) ul.appendChild(renderNode(c));\n        return li;\n      }\n    }\n\n    const ulRoot = document.createElement('ul');\n    const topChildren = Array.from(root.children.values())\n      .sort((a,b)=>{\n        if (a.type!==b.type) return a.type==='tree' ? -1 : 1;\n        return a.name.localeCompare(b.name);\n      });\n    for (const c of topChildren) ulRoot.appendChild(renderNode(c));\n\n    treeEl.innerHTML = '';\n    treeEl.appendChild(ulRoot);\n\n    treeEl.onclick = async (e)=>{\n      const twisty = e.target.closest('.twisty');\n      const name = e.target.closest('.name');\n      const dirLi = (twisty || name) ? (twisty||name).closest('li.dir') : null;\n      if (dirLi) {\n        dirLi.classList.toggle('collapsed');\n        dirLi.classList.toggle('open');\n        return;\n      }\n      const a = e.target.closest('a[data-file]');\n      if (a) {\n        e.preventDefault();\n        const f = a.dataset.file;\n        if (isSide) {\n          window.parent?.postMessage({ type:'MODULE_EVENT', eventName:'gh:file-selected', payload:{ path: f } }, '*');\n        } else {\n          await openFile(f);\n        }\n      }\n    };\n\n    const selCountChip = $('selCountChip');\n    const copyBtn = $('copyBtn');\n    const tokenCountChip = $('tokenCountChip');\n\n    function setSubtreeChecked(li, checked) {\n      li.querySelectorAll('input.sel').forEach(cb => {\n        cb.checked = checked;\n        cb.indeterminate = false;\n      });\n    }\n    function updateAncestors(fromLi) {\n      const parentDir = fromLi.closest('ul')?.closest('li.dir');\n      if (!parentDir) return;\n\n      const childCbs = Array.from(parentDir.querySelectorAll(':scope > ul > li > .row input.sel'));\n      const allChecked = childCbs.length > 0 && childCbs.every(cb => cb.checked);\n      const noneChecked = childCbs.every(cb => !cb.checked && !cb.indeterminate);\n      const parentCb = parentDir.querySelector(':scope > .row input.sel');\n\n      parentCb.checked = allChecked;\n      parentCb.indeterminate = !allChecked && !noneChecked;\n\n      updateAncestors(parentDir);\n    }\n    function collectSelectedFiles() {\n      return Array.from(treeEl.querySelectorAll('li.file input.sel:checked')).map(cb => cb.dataset.path);\n    }\n\n    async function recalcTokensUI() {\n      if (!tokenCountChip || !copyBtn) return;\n      const files = collectSelectedFiles();\n      const branch = $('branchSelect').value || 'main';\n\n      if (files.length === 0) {\n        tokenCountChip.textContent = '0 tokens';\n        copyBtn.disabled = true;\n        return;\n      }\n\n      copyBtn.disabled = false;\n      tokenCountChip.textContent = '‚Ä¶';\n      try {\n        const text = await buildClipboardText(files, branch);\n        const n = await countTokensFor(text);\n        tokenCountChip.textContent = `${n} tokens`;\n      } catch (e) {\n        console.warn('[github-hub] token recalc failed:', e);\n        tokenCountChip.textContent = '‚Äî';\n      }\n    }\n\n    function updateSelectionBadgeAndEmit() {\n      const files = collectSelectedFiles();\n      if (selCountChip) selCountChip.textContent = `${files.length} selected`;\n      if (isSide) {\n        window.parent?.postMessage(\n          { type:'MODULE_EVENT', eventName:'gh:selection-changed', payload:{ files } },\n          '*'\n        );\n      }\n      recalcTokensUI();\n    }\n\n    treeEl.onchange = (e) => {\n      const cb = e.target;\n      if (!cb.matches('input.sel')) return;\n      const li = cb.closest('li');\n      if (li?.classList.contains('dir')) {\n        setSubtreeChecked(li, cb.checked);\n      }\n      updateAncestors(li);\n      updateSelectionBadgeAndEmit();\n    };\n\n    copyBtn.onclick = async () => {\n      const files = collectSelectedFiles();\n      if (files.length === 0) {\n        alert('Select one or more files in the tree first.');\n        return;\n      }\n      const branch = $('branchSelect').value || 'main';\n      const text = await buildClipboardText(files, branch);\n\n      try {\n        await navigator.clipboard.writeText(text);\n        const old = copyBtn.textContent;\n        copyBtn.textContent = 'Copied!';\n        setTimeout(() => (copyBtn.textContent = old), 1000);\n      } catch {\n        const ta = document.createElement('textarea');\n        ta.value = text;\n        ta.style.position = 'fixed';\n        ta.style.opacity = '0';\n        document.body.appendChild(ta);\n        ta.focus();\n        ta.select();\n        document.execCommand('copy');\n        document.body.removeChild(ta);\n      }\n    };\n\n    updateSelectionBadgeAndEmit();\n\n    $('expandAllBtn').onclick = ()=>{\n      treeEl.querySelectorAll('li.dir').forEach(li=>{\n        li.classList.remove('collapsed'); li.classList.add('open');\n      });\n    };\n    $('collapseAllBtn').onclick = ()=>{\n      treeEl.querySelectorAll('li.dir').forEach(li=>{\n        li.classList.remove('open'); li.classList.add('collapsed');\n      });\n    };\n\n  }catch(e){\n    treeEl.innerHTML = `<div class=\"muted\">Failed to load tree: ${e.message}</div>`;\n  }\n  applyFilter();\n}\n\n// ---------- one-time UI wiring ----------\nlet _wired = false;\nfunction wireUIOnce(){\n  if (_wired) return;\n  _wired = true;\n\n  $('saveCfgBtn')?.addEventListener('click', saveConfig);\n  $('testCfgBtn')?.addEventListener('click', testCurrentConfig);\n  $('reloadBtn')?.addEventListener('click', loadTree);\n  $('saveFileBtn')?.addEventListener('click', saveFile);\n  $('branchSelect')?.addEventListener('change', loadTree);\n\n  $('connSelect')?.addEventListener('change', async (e) => {\n    ACTIVE_CONN = (e.target.value === 'default') ? null : e.target.value;\n    await loadBranches();\n    await loadTree();\n  });\n  $('manageConnsBtn')?.addEventListener('click', openConnManager);\n  $('closeConnBtn')?.addEventListener('click', ()=> closeModal('connModal'));\n  $('testConnModalBtn')?.addEventListener('click', async ()=>{\n    const id = $('mId').value.trim() || slugify($('mName').value) || slugify($('mRepo').value) || ('conn-' + Date.now());\n    const body = {\n      id,\n      name: $('mName').value.trim(),\n      repo_url: $('mRepo').value.trim(),\n      default_branch: $('mBranch').value.trim() || undefined,\n      base_url: $('mBase').value.trim() || 'https://api.github.com'\n    };\n    const tok = $('mTok').value.trim(); if (tok) body.token = tok;\n    const errs = validateConnInput(body);\n    if (errs.length) { toast(errs[0], false); return; }\n    try {\n      const res = await testConnectionPayload({ repo_url: body.repo_url, base_url: body.base_url, token: body.token });\n      toast(`OK ‚Ä¢ ${res.branches?.length || 0} branches`);\n    } catch(e) {\n      toast(e.message, false);\n    }\n  });\n  $('saveConnBtn')?.addEventListener('click', async ()=>{\n    const id = $('mId').value.trim() || EDITING_CONN || slugify($('mName').value) || slugify($('mRepo').value) || ('conn-' + Date.now());\n    const body = {\n      id,\n      name: $('mName').value.trim(),\n      repo_url: $('mRepo').value.trim(),\n      default_branch: $('mBranch').value.trim() || undefined,\n      base_url: $('mBase').value.trim() || 'https://api.github.com'\n    };\n    const tok = $('mTok').value.trim(); if (tok) body.token = tok;\n    const errs = validateConnInput(body);\n    if (errs.length) { toast(errs[0], false); return; }\n    try {\n      await testConnectionPayload({ repo_url: body.repo_url, base_url: body.base_url, token: body.token });\n    } catch (e) {\n      toast(`Validation failed: ${e.message}`, false);\n      return;\n    }\n    try {\n      await api('/connections', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });\n      toast('Connection saved');\n      $('mTok').value = '';\n      $('mId').value = '';\n      EDITING_CONN = null;\n      closeModal('connModal');\n      await loadConnections();\n      await loadBranches();\n      await loadTree();\n    } catch (e) { toast(e.message, false); }\n  });\n\n  $('openPrBtn')?.addEventListener('click', ()=> openModal('prModal'));\n  $('closePrBtn')?.addEventListener('click', ()=> closeModal('prModal'));\n  $('createPrBtn')?.addEventListener('click', createPR);\n\n  $('filterInput')?.addEventListener('input', applyFilter);\n}\n\n// Init\nwindow.addEventListener('DOMContentLoaded', async ()=>{\n  wireUIOnce();\n  await loadConfig();\n  await loadConnections();\n  await loadBranches();\n  await loadTree();\n});\n"
    }
  ]
}