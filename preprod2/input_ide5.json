{
  "version": "1.0",
  "backup": true,
  "changes": [
    {
      "id": "remove-sample-tree-file",
      "description": "Remove duplicated and unwanted sample file tree. This resolves the 'Identifier remoteTree has already been declared' error and removes mock data from the app.",
      "op": "delete_path",
      "path": "src/data/sampleFileTree.js",
      "recursive": false,
      "if_absent": "skip"
    },
    {
      "id": "backend-sshBridge-add-sftp-utils",
      "description": "Add SFTP helpers to list directories and read files over SSH. Expose listTree and readFileContent to support front-end file explorer.",
      "op": "patch_text",
      "path": "backend/sshBridge.js",
      "patches": [
        {
          "type": "insert_after",
          "anchor": "import { Client } from 'ssh2';",
          "replacement": "\n// Simple POSIX join to avoid pulling in 'path'\nconst joinPosix = (a, b) => (a.endsWith('/') ? a.slice(0, -1) : a) + '/' + b;\n\nfunction getSftp(client) {\n  return new Promise((resolve, reject) => {\n    client.sftp((err, sftp) => (err ? reject(err) : resolve(sftp)));\n  });\n}\n\nfunction readdirAsync(sftp, p) {\n  return new Promise((resolve, reject) => {\n    sftp.readdir(p, (err, list) => (err ? reject(err) : resolve(list || [])));\n  });\n}\n"
        },
        {
          "type": "insert_after",
          "anchor": "export function closeSession(client, stream) {",
          "replacement": ""
        },
        {
          "type": "insert_after",
          "anchor": "}\n",
          "replacement": "\nexport async function listTree(client, rootPath, depth = 2) {\n  const maxDepth = Math.max(0, Math.min(5, depth));\n  const sftp = await getSftp(client);\n\n  async function walk(path, d) {\n    const out = {};\n    let entries = [];\n    try {\n      entries = await readdirAsync(sftp, path);\n    } catch (e) {\n      // If directory cannot be read, return empty\n      return out;\n    }\n    for (const e of entries) {\n      const name = e.filename;\n      if (!name || name === '.' || name === '..') continue;\n      try {\n        if (e.attrs?.isDirectory?.()) {\n          if (d > 0) {\n            out[name] = { type: 'folder', children: await walk(joinPosix(path, name), d - 1) };\n          } else {\n            out[name] = { type: 'folder', children: {} };\n          }\n        } else if (e.attrs?.isFile?.()) {\n          out[name] = { type: 'file', size: Number(e.attrs?.size || 0), mtime: Number(e.attrs?.mtime || 0) };\n        } else {\n          // Skip symlinks and special for now\n        }\n      } catch {\n        // Skip problematic entries\n      }\n    }\n    return out;\n  }\n\n  return await walk(rootPath || '/', maxDepth);\n}\n\nexport async function readFileContent(client, remotePath) {\n  const sftp = await getSftp(client);\n  return new Promise((resolve, reject) => {\n    const chunks = [];\n    try {\n      const rs = sftp.createReadStream(remotePath, { encoding: 'utf8' });\n      rs.on('data', (c) => chunks.push(c));\n      rs.on('error', (e) => reject(new Error(e?.message || 'SFTP read error')));\n      rs.on('end', () => resolve(chunks.join('')));\n    } catch (e) {\n      reject(new Error(e?.message || 'SFTP read error'));\n    }\n  });\n}\n"
        }
      ]
    },
    {
      "id": "backend-sshManager-expose-list-and-read",
      "description": "Expose session-bound listRemote and readRemote functions using sshBridge SFTP helpers.",
      "op": "patch_text",
      "path": "backend/sshManager.js",
      "patches": [
        {
          "type": "replace_literal",
          "match": "import { connectSSH, resizePty, closeSession } from './sshBridge.js';",
          "replacement": "import { connectSSH, resizePty, closeSession, listTree, readFileContent } from './sshBridge.js';"
        },
        {
          "type": "insert_after",
          "anchor": "export function disconnect(sessionId) {",
          "replacement": ""
        },
        {
          "type": "insert_after",
          "anchor": "}\n",
          "replacement": "\nexport async function listRemote(sessionId, path, depth = 2) {\n  const s = sessions.get(sessionId);\n  if (!s) throw new Error('Invalid session');\n  return await listTree(s.client, path, depth);\n}\n\nexport async function readRemote(sessionId, path) {\n  const s = sessions.get(sessionId);\n  if (!s) throw new Error('Invalid session');\n  return await readFileContent(s.client, path);\n}\n"
        }
      ]
    },
    {
      "id": "backend-server-add-http-list-and-read",
      "description": "Add HTTP endpoints to list remote directories and read files via existing SSH sessions.",
      "op": "patch_text",
      "path": "backend/server.js",
      "patches": [
        {
          "type": "replace_literal",
          "match": "import { createSession, attachWebSocket, disconnect } from './sshManager.js';",
          "replacement": "import { createSession, attachWebSocket, disconnect, listRemote, readRemote } from './sshManager.js';"
        },
        {
          "type": "insert_after",
          "anchor": "app.post('/ssh/disconnect', (req, res) => {",
          "replacement": ""
        },
        {
          "type": "insert_after",
          "anchor": "});\n",
          "replacement": "\napp.get('/ssh/list', async (req, res) => {\n  try {\n    const sessionId = req.query.sessionId;\n    const path = req.query.path;\n    const depth = Math.max(0, Math.min(5, parseInt(req.query.depth || '2', 10)));\n    if (!sessionId || !path) return res.status(400).json({ ok: false, error: 'Missing sessionId or path' });\n    const tree = await listRemote(sessionId, path, depth);\n    return res.json({ ok: true, tree });\n  } catch (err) {\n    return res.status(500).json({ ok: false, error: err?.message || 'List failed' });\n  }\n});\n\napp.get('/ssh/read', async (req, res) => {\n  try {\n    const sessionId = req.query.sessionId;\n    const path = req.query.path;\n    if (!sessionId || !path) return res.status(400).json({ ok: false, error: 'Missing sessionId or path' });\n    const content = await readRemote(sessionId, path);\n    return res.json({ ok: true, content });\n  } catch (err) {\n    return res.status(500).json({ ok: false, error: err?.message || 'Read failed' });\n  }\n});\n"
        }
      ]
    },
    {
      "id": "frontend-api-remove-sampletree-and-add-remote-fs",
      "description": "Remove sample tree usage. On connect, fetch remote tree via backend SFTP endpoints. Add readRemoteFile and fetchRemoteTree functions.",
      "op": "patch_text",
      "path": "src/services/api.js",
      "patches": [
        {
          "type": "replace_regex",
          "match": "import\\s*\\{\\s*remoteTree\\s*\\}\\s*from\\s*'../data/sampleFileTree\\.js';\\s*",
          "replacement": ""
        },
        {
          "type": "insert_after",
          "anchor": "let activeSocket = null;",
          "replacement": "\nexport async function fetchRemoteTree(remotePath, depth = 3) {\n  if (!activeSessionId) throw new Error('No active session');\n  const url = `${BACKEND_HTTP}/ssh/list?sessionId=${encodeURIComponent(activeSessionId)}&path=${encodeURIComponent(remotePath)}&depth=${depth}`;\n  const res = await fetch(url);\n  const data = await res.json();\n  if (!data.ok) throw new Error(data.error || 'List failed');\n  return data.tree || {};\n}\n\nexport async function readRemoteFile(relPath) {\n  if (!activeSessionId) throw new Error('No active session');\n  const base = (state.remoteRoot || '').replace(/\\/$/, '');\n  const fullPath = base + (relPath.startsWith('/') ? relPath : '/' + relPath);\n  const url = `${BACKEND_HTTP}/ssh/read?sessionId=${encodeURIComponent(activeSessionId)}&path=${encodeURIComponent(fullPath)}`;\n  const res = await fetch(url);\n  const data = await res.json();\n  if (!data.ok) throw new Error(data.error || 'Read failed');\n  return data.content ?? '';\n}\n"
        },
        {
          "type": "replace_regex",
          "match": "activeSocket\\.onopen\\s*=\\s*\\(\\)\\s*=>\\s*\\{[\\s\\S]*?\\};",
          "replacement": "activeSocket.onopen = async () => {\n      state.isConnected = true; state.currentWorkspace = 'remote';\n      state.remoteRoot = config.remotePath || '/';\n      updateConnectionStatus(true, config.host);\n      updateWorkspaceIndicator('Remote: ' + config.host);\n      document.getElementById('connectBtn')?.classList.add('hidden');\n      document.getElementById('disconnectBtn')?.classList.remove('hidden');\n      document.getElementById('terminalHost').textContent = config.host;\n      addToTerminal(`Connected to ${config.host}`);\n      showNotification(`‚úÖ Connected to ${config.host}`, 'success');\n      bus.emit('workspace:changed', { connected: true, host: config.host });\n      // Load remote file tree\n      try {\n        const tree = await fetchRemoteTree(state.remoteRoot, 3);\n        bus.emit('fileTree:replace', { tree });\n      } catch (err) {\n        showNotification('‚ö†Ô∏è Failed to load remote file tree: ' + (err?.message || err), 'warning');\n        bus.emit('fileTree:replace', { tree: {} });\n      }\n    };"
        },
        {
          "type": "replace_regex",
          "match": "state\\.isConnected\\s*=\\s*false;\\s*state\\.currentWorkspace\\s*=\\s*'local';[\\s\\S]*?bus\\.emit\\('workspace:changed',[\\s\\S]*?\\);",
          "replacement": "state.isConnected = false; state.currentWorkspace = 'local'; state.remoteRoot = null;\n  updateConnectionStatus(false);\n  updateWorkspaceIndicator('Local');\n  bus.emit('fileTree:replace', { tree: {} });\n  document.getElementById('connectBtn')?.classList.remove('hidden');\n  document.getElementById('disconnectBtn')?.classList.add('hidden');\n  document.getElementById('terminalHost').textContent = 'localhost';\n  addToTerminal('Disconnected from remote server');\n  showNotification('üîå Disconnected from SSH', 'info');\n  bus.emit('workspace:changed', { connected: false, host: 'localhost' });"
        }
      ]
    },
    {
      "id": "frontend-main-remove-sampletree-and-lazy-load-files",
      "description": "Remove local sample tree usage and avoid opening default README. Implement lazy remote file loading on file open. Initialize auth UI state.",
      "op": "patch_text",
      "path": "src/main.js",
      "patches": [
        {
          "type": "replace_regex",
          "match": "import\\s*\\{\\s*localTree\\s*\\}\\s*from\\s*'./data/sampleFileTree\\.js';\\s*",
          "replacement": ""
        },
        {
          "type": "replace_literal",
          "match": " state.fileTree = localTree;",
          "replacement": " state.fileTree = {};"
        },
        {
          "type": "replace_regex",
          "match": "setTimeout\\(\\s*\\(\\)\\s*=>\\s*\\{[\\s\\S]*?\\},\\s*200\\s*\\);",
          "replacement": "setTimeout(() => {\n renderFileTree();\n updateGitStatus();\n }, 200);"
        },
        {
          "type": "replace_regex",
          "match": "bus\\.on\\('file:open',[\\s\\S]*?\\);",
          "replacement": "bus.on('file:open', ({ path }) => {\n const file = getFileFromPath(path);\n if (!file || file.type !== 'file') return;\n if (!state.openFiles.has(path)) {\n   state.openFiles.set(path, { content: file.content ?? '', originalContent: file.content ?? '', modified: false });\n }\n state.activeFile = path;\n updateTabs();\n if (state.editor) { loadFileInEditor(path); }\n bus.emit('ui:fileTree:selection');\n setStatus(`üìñ Opened ${path}`);\n const lang = (getLanguageFromPath(path) || 'plaintext').toUpperCase();\n const lm = qs('#languageMode'); if (lm) lm.textContent = lang;\n // Lazy-load content from remote if missing\n if (file.content == null && state.isConnected) {\n   API.readRemoteFile(path)\n     .then((content) => {\n       file.content = content;\n       const entry = state.openFiles.get(path);\n       if (entry) {\n         entry.content = content;\n         entry.originalContent = content;\n         entry.modified = false;\n       }\n       if (state.activeFile === path && state.editor) { loadFileInEditor(path); }\n       updateTabs();\n       bus.emit('ui:fileTree:selection');\n     })\n     .catch((e) => console.warn('Failed to load remote file', path, e));\n }\n});"
        },
        {
          "type": "insert_after",
          "anchor": "qs('#authMethod')?.addEventListener('change', (e) => {",
          "replacement": ""
        },
        {
          "type": "insert_after",
          "anchor": "});\n",
          "replacement": "\n // Initialize password field visibility based on default selection\n const authSel = qs('#authMethod');\n if (authSel) {\n   const group = qs('#passwordGroup');\n   if (group) group.classList.toggle('hidden', authSel.value !== 'password');\n }\n"
        }
      ]
    },
    {
      "id": "frontend-fileTree-no-change-render-ensure",
      "description": "No code change; kept as a marker to indicate file tree rendering remains the same but now receives dynamic remote tree.",
      "op": "patch_text",
      "path": "src/ui/fileTree.js",
      "patches": []
    },
    {
      "id": "frontend-ssh-service-keep-compat",
      "description": "No changes required; connect() continues to pass remotePath to API.connectSSH used to set remote root and fetch tree.",
      "op": "patch_text",
      "path": "src/services/ssh.js",
      "patches": []
    }
  ]
}