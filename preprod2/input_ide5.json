{
  "version": "1.0",
  "project_root": "preprod2",
  "dry_run": false,
  "backup": true,
  "changes": [
    {
      "id": "backend-sshBridge-add-write-mkdir",
      "description": "Add SFTP write and mkdir helpers to sshBridge.js",
      "op": "patch_text",
      "path": "backend/sshBridge.js",
      "patches": [
        {
          "type": "insert_before",
          "anchor": "function readdirAsync",
          "replacement": "\nexport async function writeFileContent(client, remotePath, content = '') {\n  const sftp = await getSftp(client);\n  return new Promise((resolve, reject) => {\n    try {\n      const ws = sftp.createWriteStream(remotePath, { encoding: 'utf8' });\n      ws.on('error', (e) => reject(new Error(e?.message || 'SFTP write error')));\n      ws.on('finish', () => resolve(true));\n      ws.end(content ?? '');\n    } catch (e) {\n      reject(new Error(e?.message || 'SFTP write error'));\n    }\n  });\n}\n\nexport async function makeDirectory(client, remotePath, { recursive = true } = {}) {\n  const sftp = await getSftp(client);\n  const parts = remotePath.split('/').filter(Boolean);\n  const roots = remotePath.startsWith('/') ? [''] : [];\n  let cur = roots.length ? '/' : '';\n  for (const part of parts) {\n    cur = cur.endsWith('/') ? cur + part : cur + '/' + part;\n    try {\n      /* eslint-disable no-await-in-loop */\n      await new Promise((resolve, reject) => sftp.mkdir(cur, (err) => (err ? reject(err) : resolve())));\n    } catch (e) {\n      if (!/Failure|exist|EEXIST/i.test(String(e?.message || e))) {\n        if (!recursive) throw e;\n      }\n    }\n  }\n  return true;\n}\n"
        }
      ]
    },
    {
      "id": "backend-sshManager-imports",
      "description": "Expose writeRemote and mkdirRemote in sshManager.js (imports)",
      "op": "patch_text",
      "path": "backend/sshManager.js",
      "patches": [
        {
          "type": "replace_regex",
          "match": "^import\\s+\\{\\s*connectSSH,\\s*resizePty,\\s*closeSession,\\s*listTree,\\s*readFileContent\\s*\\}\\s*from\\s*'\\.\\/sshBridge\\.js';",
          "replacement": "import { connectSSH, resizePty, closeSession, listTree, readFileContent, writeFileContent, makeDirectory } from './sshBridge.js';",
          "regex": true
        },
        {
          "type": "insert_before",
          "anchor": "export function disconnect(sessionId) {",
          "replacement": "\nexport async function writeRemote(sessionId, path, content) {\n  const s = sessions.get(sessionId);\n  if (!s) throw new Error('Invalid session');\n  return await writeFileContent(s.client, path, content);\n}\n\nexport async function mkdirRemote(sessionId, path, options) {\n  const s = sessions.get(sessionId);\n  if (!s) throw new Error('Invalid session');\n  return await makeDirectory(s.client, path, options);\n}\n\n"
        }
      ]
    },
    {
      "id": "backend-server-imports",
      "description": "Add write/mkdir endpoints (imports) in server.js",
      "op": "patch_text",
      "path": "backend/server.js",
      "patches": [
        {
          "type": "replace_regex",
          "match": "^import\\s+\\{\\s*createSession,\\s*attachWebSocket,\\s*disconnect,\\s*listRemote,\\s*readRemote\\s*\\}\\s*from\\s*'\\.\\/sshManager\\.js';",
          "replacement": "import { createSession, attachWebSocket, disconnect, listRemote, readRemote, writeRemote, mkdirRemote } from './sshManager.js';",
          "regex": true
        }
      ]
    },
    {
      "id": "backend-server-endpoints",
      "description": "Add /ssh/write and /ssh/mkdir endpoints in server.js",
      "op": "patch_text",
      "path": "backend/server.js",
      "patches": [
        {
          "type": "insert_before",
          "anchor": "app.post('/ssh/disconnect',",
          "replacement": "\napp.post('/ssh/write', async (req, res) => {\n  try {\n    const { sessionId, path, content } = req.body || {};\n    if (!sessionId || !path) return res.status(400).json({ ok: false, error: 'Missing sessionId or path' });\n    await writeRemote(sessionId, path, content ?? '');\n    return res.json({ ok: true });\n  } catch (err) {\n    console.error('[api] write failed', err?.message || err);\n    return res.status(500).json({ ok: false, error: err?.message || 'Write failed' });\n  }\n});\n\napp.post('/ssh/mkdir', async (req, res) => {\n  try {\n    const { sessionId, path, recursive = true } = req.body || {};\n    if (!sessionId || !path) return res.status(400).json({ ok: false, error: 'Missing sessionId or path' });\n    await mkdirRemote(sessionId, path, { recursive: !!recursive });\n    return res.json({ ok: true });\n  } catch (err) {\n    console.error('[api] mkdir failed', err?.message || err);\n    return res.status(500).json({ ok: false, error: err?.message || 'Mkdir failed' });\n  }\n});\n\n"
        }
      ]
    },
    {
      "id": "frontend-api-add-write-mkdir",
      "description": "Add writeRemoteFile and makeRemoteDir helpers in src/services/api.js",
      "op": "patch_text",
      "path": "src/services/api.js",
      "patches": [
        {
          "type": "insert_after",
          "anchor": "return data.content ?? '';\n}",
          "replacement": "\n\nexport async function writeRemoteFile(relPath, content) {\n  if (!activeSessionId) throw new Error('No active session');\n  const base = (state.remoteRoot || '').replace(/\\/$/, '');\n  const fullPath = base + (relPath.startsWith('/') ? relPath : '/' + relPath);\n  const res = await fetch(`${BACKEND_HTTP}/ssh/write`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ sessionId: activeSessionId, path: fullPath, content })\n  });\n  const data = await res.json();\n  if (!data.ok) throw new Error(data.error || 'Write failed');\n  return true;\n}\n\nexport async function makeRemoteDir(relPath, { recursive = true } = {}) {\n  if (!activeSessionId) throw new Error('No active session');\n  const base = (state.remoteRoot || '').replace(/\\/$/, '');\n  const fullPath = base + (relPath.startsWith('/') ? relPath : '/' + relPath);\n  const res = await fetch(`${BACKEND_HTTP}/ssh/mkdir`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ sessionId: activeSessionId, path: fullPath, recursive })\n  });\n  const data = await res.json();\n  if (!data.ok) throw new Error(data.error || 'Mkdir failed');\n  return true;\n}\n"
        }
      ]
    },
    {
      "id": "frontend-main-remote-create-file",
      "description": "Create remote file immediately when connected (newFile)",
      "op": "patch_text",
      "path": "src/main.js",
      "patches": [
        {
          "type": "insert_after",
          "anchor": "setStatus(`üìÑ Created ${fileName}`);",
          "replacement": "\n\n  // If connected, immediately write to remote so it truly exists\n  if (state.isConnected) {\n    API.writeRemoteFile(fileName, content)\n      .then(() => showNotification(`‚úÖ Created remote file ${fileName}`, 'success'))\n      .catch((e) => showNotification(`‚ö†Ô∏è Remote create failed: ${e?.message || e}`, 'warning'));\n  }\n"
        }
      ]
    },
    {
      "id": "frontend-main-remote-mkdir",
      "description": "Create remote folder when connected (newFolder)",
      "op": "patch_text",
      "path": "src/main.js",
      "patches": [
        {
          "type": "insert_after",
          "anchor": "setStatus(`üìÅ Created folder ${folderName}`);",
          "replacement": "\n\n  if (state.isConnected) {\n    API.makeRemoteDir(folderName, { recursive: true })\n      .then(() => showNotification(`‚úÖ Created remote folder ${folderName}`, 'success'))\n      .catch((e) => showNotification(`‚ö†Ô∏è Remote mkdir failed: ${e?.message || e}`, 'warning'));\n  }\n"
        }
      ]
    },
    {
      "id": "frontend-main-upload-remote",
      "description": "Upload button: push files to remote if connected",
      "op": "patch_text",
      "path": "src/main.js",
      "patches": [
        {
          "type": "replace_regex",
          "match": "reader\\.onload\\s*=\\s*\\(ev\\)\\s*=>\\s*\\{[\\s\\S]*?\\};",
          "replacement": "reader.onload = (ev) => {\n  const text = String(ev.target.result || '');\n  // Update UI tree\n  state.fileTree[file.name] = { type: 'file', content: text };\n  renderFileTree();\n  // If connected, push to remote\n  if (state.isConnected) {\n    API.writeRemoteFile(file.name, text)\n      .then(() => showNotification(`‚¨ÜÔ∏è Uploaded to remote: ${file.name}`, 'success'))\n      .catch((err) => showNotification(`‚ö†Ô∏è Remote upload failed: ${err?.message || err}`, 'warning'));\n  } else {\n    showNotification(`‚¨ÜÔ∏è Uploaded locally: ${file.name}`, 'success');\n  }\n};",
          "regex": true
        }
      ]
    },
    {
      "id": "frontend-main-save-remote",
      "description": "Save current file also writes to remote when connected",
      "op": "patch_text",
      "path": "src/main.js",
      "patches": [
        {
          "type": "replace_between",
          "start": "function saveCurrentFile() {",
          "end": "}\n\nfunction saveAllFiles() {",
          "replacement": "function saveCurrentFile() {\n  if (!state.activeFile || !state.editor) return;\n  const content = getEditorValue();\n  const fileData = state.openFiles.get(state.activeFile);\n  if (!fileData) return;\n\n  fileData.originalContent = content;\n  fileData.modified = false;\n\n  const f = getFileFromPath(state.activeFile);\n  if (f) f.content = content;\n\n  updateTabs();\n  bus.emit('ui:fileTree:selection');\n  setStatus(`üíæ Saved ${state.activeFile}`);\n  if (state.isConnected) {\n    API.writeRemoteFile(state.activeFile, content)\n      .then(() => showNotification(`‚úÖ Remote saved: ${state.activeFile}`, 'success'))\n      .catch((e) => showNotification(`‚ö†Ô∏è Remote save failed: ${e?.message || e}`, 'warning'));\n  } else {\n    showNotification(`‚úÖ File saved: ${state.activeFile.split('/').pop()}`, 'success');\n  }\n}\n\nfunction saveAllFiles() {",
          "include_anchors": true
        }
      ]
    },
    {
      "id": "frontend-index-add-key-file-loader",
      "description": "Add key file input/button to load PEM into textarea",
      "op": "patch_text",
      "path": "index.html",
      "patches": [
        {
          "type": "insert_after",
          "anchor": "<textarea id=\"sshPrivateKey\"",
          "replacement": "",
          "regex": false
        },
        {
          "type": "insert_after",
          "anchor": "</textarea>",
          "replacement": "\n              <div class=\"row gap-8 top-16\">\n                <input type=\"file\" id=\"sshKeyFile\" accept=\".pem,.key,.txt\" />\n                <button class=\"btn small secondary\" id=\"sshKeyFileLoadBtn\" type=\"button\">Load Key File</button>\n              </div>"
        }
      ]
    },
    {
      "id": "frontend-main-wire-key-file-loader",
      "description": "Wire key file picker to fill textarea in main.js",
      "op": "patch_text",
      "path": "src/main.js",
      "patches": [
        {
          "type": "insert_after",
          "anchor": "if (authSel) updateAuthGroups(authSel.value);",
          "replacement": "\n\n  // SSH key file ‚Üí textarea helper\n  const keyInput = qs('#sshKeyFile');\n  const keyBtn = qs('#sshKeyFileLoadBtn');\n  const keyText = qs('#sshPrivateKey');\n  const loadKeyToTextarea = (file) => {\n    if (!file) return;\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      if (keyText) keyText.value = String(e.target.result || '');\n      showNotification(`üîê Loaded key: ${file.name}`, 'success');\n    };\n    reader.readAsText(file);\n  };\n  keyInput?.addEventListener('change', (e) => {\n    const f = e.target.files?.[0];\n    if (f) loadKeyToTextarea(f);\n  });\n  keyBtn?.addEventListener('click', () => {\n    if (keyInput?.files?.length) loadKeyToTextarea(keyInput.files[0]);\n    else keyInput?.click();\n  });\n"
        }
      ]
    },
    {
      "id": "frontend-ssh-trim-and-key-check",
      "description": "Trim host/username and ensure key text not blank in src/services/ssh.js",
      "op": "patch_text",
      "path": "src/services/ssh.js",
      "patches": [
        {
          "type": "replace_regex",
          "match": "host:\\s*document\\.getElementById\\('sshHost'\\)\\?\\.value,",
          "replacement": "host: (document.getElementById('sshHost')?.value || '').trim(),",
          "regex": true
        },
        {
          "type": "replace_regex",
          "match": "username:\\s*document\\.getElementById\\('sshUsername'\\)\\?\\.value,",
          "replacement": "username: (document.getElementById('sshUsername')?.value || '').trim(),",
          "regex": true
        },
        {
          "type": "replace_regex",
          "match": "if \\(config\\.authMethod === 'key' && !config\\.privateKey\\)\\{ showNotification\\('‚ùå Provide a private key \\(upload or paste\\)', 'error'\\); return; \\}",
          "replacement": "if (config.authMethod === 'key' && !(config.privateKey || '').trim()){ showNotification('‚ùå Provide a private key (upload or paste)', 'error'); return; }",
          "regex": true
        }
      ]
    }
  ]
}
