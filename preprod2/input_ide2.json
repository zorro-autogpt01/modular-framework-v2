{
  "version": "1.0",
  "backup": true,
  "changes": [
    {
      "id": "frontend_index_add_key_group",
      "description": "Insert SSH key UI group before Remote Path input in SSH panel",
      "op": "patch_text",
      "path": "index.html",
      "patches": [
        {
          "type": "insert_before",
          "anchor": "<div class=\"input-group\">\\s*<label for=\"remotePath\">Remote Path</label>",
          "regex": true,
          "replacement": "            <!-- Key fields (shown when authMethod = key) -->\n            <div id=\"keyGroup\" class=\"\">\n              <div class=\"input-group\">\n                <label for=\"sshPrivateKeyFile\">Private Key (upload)</label>\n                <input type=\"file\" id=\"sshPrivateKeyFile\" accept=\".pem,.key,.txt,.pub,.ppk\" />\n              </div>\n              <div class=\"input-group\">\n                <label for=\"sshPrivateKey\">Private Key (paste)</label>\n                <textarea id=\"sshPrivateKey\" class=\"db-query-editor\" placeholder=\"-----BEGIN OPENSSH PRIVATE KEY-----\\n...\\n-----END OPENSSH PRIVATE KEY-----\"></textarea>\n              </div>\n              <div class=\"input-group\">\n                <label for=\"sshPassphrase\">Passphrase (optional)</label>\n                <input type=\"password\" id=\"sshPassphrase\" />\n              </div>\n            </div>\n\n"
        }
      ]
    },
    {
      "id": "frontend_main_auth_toggle_update",
      "description": "Enhance authMethod toggle to support keyGroup as well",
      "op": "patch_text",
      "path": "src/main.js",
      "patches": [
        {
          "type": "replace_between",
          "start": "// Auth method change",
          "end": "});",
          "include_anchors": true,
          "replacement": "// Auth method change\n    qs('#authMethod')?.addEventListener('change', (e) => {\n      const v = e.target.value;\n      const pass = qs('#passwordGroup');\n      const keyg = qs('#keyGroup');\n      pass?.classList.toggle('hidden', v !== 'password');\n      keyg?.classList.toggle('hidden', v !== 'key');\n    });"
        },
        {
          "type": "insert_after",
          "anchor": "Logger.info('IDE initialized');",
          "replacement": "\n\n    // Key upload â†’ populate textarea, keep in memory only\n    const keyFileInput = qs('#sshPrivateKeyFile');\n    const keyTextArea = qs('#sshPrivateKey');\n    keyFileInput?.addEventListener('change', async (e) => {\n      const file = e.target.files?.[0];\n      if (!file) return;\n      const text = await file.text();\n      if (keyTextArea) keyTextArea.value = text;\n    });\n"
        }
      ]
    },
    {
      "id": "frontend_api_real_backend",
      "description": "Replace simulated API with real SSH backend integration",
      "op": "write_file",
      "path": "src/services/api.js",
      "mode": "overwrite",
      "content": "import { state } from '../core/state.js';\nimport { bus } from '../core/eventBus.js';\nimport { showNotification } from '../ui/notifications.js';\nimport { updateConnectionStatus, updateWorkspaceIndicator } from '../ui/panels.js';\nimport { remoteTree } from '../data/sampleFileTree.js';\nimport { addToTerminal } from '../terminal/index.js';\n\nconst BACKEND_HTTP = window.__BACKEND_URL || 'http://localhost:3001';\nconst BACKEND_WS = (BACKEND_HTTP.startsWith('https') ? 'wss' : 'ws') + '://' + BACKEND_HTTP.replace(/^https?:\\/\\//, '') + '/ssh';\n\nlet activeSessionId = null;\nlet activeSocket = null;\n\nexport function getActiveSocket(){ return activeSocket; }\nexport function getActiveSession(){ return activeSessionId; }\n\nexport async function connectSSH(config){\n  showNotification('ðŸ”— Connecting to SSH...', 'info');\n  try {\n    const res = await fetch(`${BACKEND_HTTP}/ssh/connect`, {\n      method: 'POST', headers: { 'Content-Type': 'application/json' },\n      // Never log this body; it contains secrets\n      body: JSON.stringify(config)\n    });\n    const data = await res.json();\n    if (!data.ok) throw new Error(data.error || 'Connect failed');\n\n    activeSessionId = data.sessionId;\n    // Open WS for interactive shell\n    activeSocket = new WebSocket(`${BACKEND_WS}?sessionId=${encodeURIComponent(activeSessionId)}`);\n\n    activeSocket.binaryType = 'arraybuffer';\n    activeSocket.onopen = () => {\n      state.isConnected = true; state.currentWorkspace = 'remote';\n      updateConnectionStatus(true, config.host);\n      updateWorkspaceIndicator('Remote: ' + config.host);\n      bus.emit('fileTree:replace', { tree: remoteTree });\n      document.getElementById('connectBtn')?.classList.add('hidden');\n      document.getElementById('disconnectBtn')?.classList.remove('hidden');\n      document.getElementById('terminalHost').textContent = config.host;\n      addToTerminal(`Connected to ${config.host}`);\n      showNotification(`âœ… Connected to ${config.host}`, 'success');\n      bus.emit('workspace:changed', { connected: true, host: config.host });\n    };\n\n    activeSocket.onmessage = (ev) => {\n      const text = typeof ev.data === 'string' ? ev.data : new TextDecoder().decode(new Uint8Array(ev.data));\n      addToTerminal(text);\n    };\n\n    activeSocket.onclose = () => {\n      // Socket closed; leave UI cleanup to disconnect or remote exit\n    };\n\n    return { success: true, host: config.host };\n  } catch (e) {\n    showNotification('âŒ Connection failed: ' + (e?.message || e), 'error');\n    throw e;\n  }\n}\n\nexport async function disconnectSSH(){\n  try {\n    if (activeSessionId) {\n      await fetch(`${BACKEND_HTTP}/ssh/disconnect`, {\n        method: 'POST', headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId: activeSessionId })\n      });\n    }\n  } catch {}\n  try { activeSocket?.close(); } catch {}\n  activeSocket = null; activeSessionId = null;\n\n  state.isConnected = false; state.currentWorkspace = 'local';\n  updateConnectionStatus(false);\n  updateWorkspaceIndicator('Local');\n  bus.emit('fileTree:replace', { tree: {} });\n  document.getElementById('connectBtn')?.classList.remove('hidden');\n  document.getElementById('disconnectBtn')?.classList.add('hidden');\n  document.getElementById('terminalHost').textContent = 'localhost';\n  addToTerminal('Disconnected from remote server');\n  showNotification('ðŸ”Œ Disconnected from SSH', 'info');\n  bus.emit('workspace:changed', { connected: false, host: 'localhost' });\n  return { success: true };\n}\n\nexport async function executeGitCommand(command){\n  // unchanged (simulated)\n  return new Promise(resolve=>{\n    setTimeout(()=>{\n      addToTerminal(`$ ${command}`);\n      const output = simulateGitOutput(command);\n      addToTerminal(output);\n      resolve({ output, success: true });\n    }, 400);\n  });\n}\n\nexport async function executeRemoteCommand(command){\n  // If we have an SSH WS, write to shell; otherwise simulated\n  if (activeSocket && activeSocket.readyState === WebSocket.OPEN){\n    activeSocket.send(JSON.stringify({ type:'data', data: command + '\\n' }));\n    return { output: '', exitCode: 0 };\n  }\n  return new Promise(resolve=>{\n    setTimeout(()=>{ resolve({ output: simulateCommandOutput(command), exitCode: 0 }); }, 300);\n  });\n}\n\nexport function executeGitHubAction(){\n  const token = document.getElementById('githubToken')?.value;\n  const repoUrl = document.getElementById('repoUrl')?.value;\n  if (!token || !repoUrl){ showNotification('âš ï¸ Please fill in all fields', 'warning'); return; }\n  showNotification('ðŸ™ Executing GitHub action...', 'info');\n  setTimeout(()=>{ showNotification('âœ… GitHub integration successful', 'success'); document.querySelector('#githubModal')?.classList.add('hidden'); }, 800);\n}\n\nfunction simulateCommandOutput(cmd){\n  const outputs = {\n    'ls': 'total 8\\ndrwxr-xr-x  3 user user 4096 projects\\n-rw-r--r--  1 user user  220 .bashrc',\n    'pwd': state.currentWorkspace === 'remote' ? '/home/developer' : '/Users/developer',\n    'whoami': 'developer',\n    'node --version': 'v18.17.1',\n    'npm --version': '9.8.1'\n  };\n  return outputs[cmd] || `Command executed: ${cmd}`;\n}\n\nfunction simulateGitOutput(command){\n  const outputs = {\n    'git status': 'On branch main\\nYour branch is up to date with \"origin/main\".\\nNothing to commit, working tree clean',\n    'git pull origin main': 'Already up to date.',\n    'git push origin main': 'Everything up-to-date',\n    'git add .': 'Files staged for commit',\n    'git fetch': 'Already up to date.'\n  };\n  for (const [key,val] of Object.entries(outputs)) if (command.startsWith(key)) return val;\n  return 'Git command executed successfully';\n}\n"
    },
    {
      "id": "frontend_ssh_connect_update",
      "description": "Update SSH connect to include key, passphrase and validation",
      "op": "write_file",
      "path": "src/services/ssh.js",
      "mode": "overwrite",
      "content": "import * as API from './api.js';\nimport { showNotification } from '../ui/notifications.js';\n\nexport async function connect(){\n  const config = {\n    host: document.getElementById('sshHost')?.value,\n    port: Number(document.getElementById('sshPort')?.value||22),\n    username: document.getElementById('sshUsername')?.value,\n    authMethod: document.getElementById('authMethod')?.value,\n    password: document.getElementById('sshPassword')?.value,\n    privateKey: document.getElementById('sshPrivateKey')?.value,\n    passphrase: document.getElementById('sshPassphrase')?.value,\n    remotePath: document.getElementById('remotePath')?.value\n  };\n  if (!config.host || !config.username){ showNotification('âŒ Please fill in required fields', 'error'); return; }\n  if (config.authMethod === 'password' && !config.password){ showNotification('âŒ Password is required', 'error'); return; }\n  if (config.authMethod === 'key' && !config.privateKey){ showNotification('âŒ Provide a private key (upload or paste)', 'error'); return; }\n  try{ await API.connectSSH(config); }catch(e){ /* handled in API */ }\n}\n\nexport async function disconnect(){ await API.disconnectSSH(); }\n"
    },
    {
      "id": "frontend_terminal_ctrl_c",
      "description": "Add Ctrl+C support to terminal input",
      "op": "patch_text",
      "path": "src/terminal/index.js",
      "patches": [
        {
          "type": "insert_after",
          "anchor": "export function initTerminal(){",
          "replacement": "\n  const input = qs('#terminalInput');\n  input?.addEventListener('keydown', (e)=>{\n    if (e.ctrlKey && e.key.toLowerCase() === 'c'){\n      const ws = API.getActiveSocket?.();\n      if (ws && ws.readyState === WebSocket.OPEN){ ws.send(JSON.stringify({ type:'data', data: '\\u0003' })); }\n      e.preventDefault();\n    }\n  });\n"
        }
      ]
    }
  ]
}