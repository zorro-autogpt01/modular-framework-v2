{
"$schema": "[https://json-schema.org/draft/2020-12/schema](https://json-schema.org/draft/2020-12/schema)",
"$id": "[https://example.com/code-change-plan.schema.json](https://example.com/code-change-plan.schema.json)",
"title": "CodeChangePlan",
"type": "object",
"required": ["version", "changes"],
"additionalProperties": false,
"properties": {
"version": { "type": "string", "const": "1.0" },
"project_root": { "type": "string", "description": "Base dir to apply paths against (optional; can be overridden by CLI)" },
"dry_run": { "type": "boolean", "default": false },
"backup": { "type": "boolean", "default": true, "description": "Create .bak files before modifications" },
"changes": {
"type": "array",
"items": { "$ref": "#/$defs/change" }
}
},
"version": "1.0",
"project_root": "modular-framework",
"dry_run": false,
"backup": true,
"changes": [
{
"id": "runner-controller-dockerfile",
"description": "Create Dockerfile for llm-runner-controller",
"op": "write_file",
"path": "modules/llm-runner-controller/Dockerfile",
"mode": "overwrite",
"content": "FROM node:20-alpine\nWORKDIR /app\n\n# System deps for Prisma (SQLite)\nRUN apk add --no-cache openssl bash\n\nCOPY package.json package-lock.json* ./\nRUN npm ci --omit=dev\n\nCOPY prisma ./prisma\nRUN npx prisma generate\n\nCOPY server ./server\n\nENV NODE_ENV=production\nENV PORT=4015\nEXPOSE 4015\n\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\n  CMD wget -qO- http://localhost:$PORT/health || exit 1\n\nCMD [\"node\", \"server/index.js\"]\n"
},
{
"id": "runner-controller-package",
"description": "package.json for controller",
"op": "write_file",
"path": "modules/llm-runner-controller/package.json",
"mode": "overwrite",
"content": "{\n  \"name\": \"llm-runner-controller\",\n  \"version\": \"0.1.0\",\n  \"type\": \"commonjs\",\n  \"main\": \"server/index.js\",\n  \"scripts\": {\n    \"start\": \"node server/index.js\",\n    \"dev\": \"NODE_ENV=development nodemon server/index.js\",\n    \"prisma:generate\": \"prisma generate\",\n    \"prisma:migrate\": \"prisma migrate deploy\"\n  },\n  \"dependencies\": {\n    \"@prisma/client\": \"5.18.0\",\n    \"argon2\": \"0.40.3\",\n    \"axios\": \"1.7.4\",\n    \"body-parser\": \"1.20.2\",\n    \"cors\": \"2.8.5\",\n    \"express\": \"4.19.2\",\n    \"eventsource-parser\": \"1.1.2\",\n    \"morgan\": \"1.10.0\",\n    \"nanoid\": \"5.0.7\"\n  },\n  \"devDependencies\": {\n    \"prisma\": \"5.18.0\",\n    \"nodemon\": \"3.1.4\"\n  }\n}\n"
},
{
"id": "runner-controller-index",
"description": "Controller entrypoint",
"op": "write_file",
"path": "modules/llm-runner-controller/server/index.js",
"mode": "overwrite",
"content": "// llm-runner-controller/server/index.js\nconst app = require('./app');\nconst PORT = Number(process.env.PORT || 4015);\napp.listen(PORT, () => {\n  console.log(`llm-runner-controller listening on :${PORT}`);\n});\n"
},
{
"id": "runner-controller-app",
"description": "Controller Express app with routes",
"op": "write_file",
"path": "modules/llm-runner-controller/server/app.js",
"mode": "overwrite",
"content": "// llm-runner-controller/server/app.js\nconst express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst morgan = require('morgan');\nconst { requireAdmin, requireReg, requireAgentAuth, optionalAdmin } = require('./auth');\nconst registry = require('./services/registry');\nconst health = require('./services/health');\nconst execSvc = require('./services/exec');\nconst configs = require('./services/configs');\nconst updates = require('./services/updates');\nconst events = require('./services/events');\nconst installers = require('./services/installers');\n\nconst app = express();\napp.use(cors({ origin: true, credentials: true }));\napp.use(bodyParser.json({ limit: '2mb' }));\napp.use(morgan('tiny'));\n\napp.get('/health', (_req, res) => res.json({ status: 'healthy' }));\n\n// Agents\napp.get('/api/llm-runner/agents', optionalAdmin, registry.list);\napp.post('/api/llm-runner/agents', requireAdmin, registry.upsert);\napp.post('/api/llm-runner/agents/register', requireReg, registry.selfRegister);\napp.get('/api/llm-runner/agents/:id', optionalAdmin, registry.get);\napp.delete('/api/llm-runner/agents/:id', requireAdmin, registry.remove);\napp.post('/api/llm-runner/agents/:id/ping', requireAdmin, health.pingNow);\napp.get('/api/llm-runner/agents/:id/health', requireAdmin, health.proxy);\napp.post('/api/llm-runner/agents/:id/exec', requireAdmin, execSvc.run);\n\n// Discovery\napp.get('/api/llm-runner/catalog', registry.catalog);\n\n// Configs\napp.get('/api/llm-runner/configs', requireAdmin, configs.list);\napp.post('/api/llm-runner/configs', requireAdmin, configs.create);\napp.post('/api/llm-runner/agents/:id/configs/assign', requireAdmin, configs.assign);\napp.get('/api/llm-runner/agents/:id/configs/effective', requireAdmin, configs.effective);\napp.get('/api/llm-runner/agents/:id/configs/pull', configs.pullForAgent); // agent uses its own token\n\n// Updates\napp.post('/api/llm-runner/agents/:id/update', requireAdmin, updates.trigger);\napp.get('/api/llm-runner/updates/:updId', requireAdmin, updates.get);\n\n// Events (SSE)\napp.get('/api/llm-runner/events', events.sse);\n\n// Installers\napp.get('/install/runner.sh', installers.dockerScript);\napp.get('/install/systemd.sh', installers.systemdScript);\n\nmodule.exports = app;\n"
},
{
"id": "runner-controller-auth",
"description": "Admin/registration/agent auth helpers",
"op": "write_file",
"path": "modules/llm-runner-controller/server/auth.js",
"mode": "overwrite",
"content": "// llm-runner-controller/server/auth.js\nconst { db } = require('./db');\n\nfunction bearer(req){\n  const h = req.headers['authorization'] || ''; return h.startsWith('Bearer ')? h.slice(7): '';\n}\n\nfunction requireAdmin(req,res,next){\n  const tok = bearer(req);\n  if (!process.env.INTERNAL_API_TOKEN) return res.status(503).json({ error:'admin token not configured' });\n  if (tok === process.env.INTERNAL_API_TOKEN) return next();\n  return res.status(401).json({ error:'unauthorized' });\n}\nfunction optionalAdmin(req,res,next){\n  if (!process.env.INTERNAL_API_TOKEN) return next();\n  if (bearer(req) === process.env.INTERNAL_API_TOKEN) return next();\n  return next();\n}\nfunction requireReg(req,res,next){\n  const tok = bearer(req);\n  if (!process.env.RUNNER_REG_TOKEN) return res.status(503).json({ error:'registration disabled' });\n  if (tok === process.env.RUNNER_REG_TOKEN) return next();\n  return res.status(401).json({ error:'unauthorized' });\n}\n\nasync function requireAgentAuth(req,res,next){\n  try {\n    const tok = bearer(req);\n    if (!tok) return res.status(401).json({ error:'unauthorized' });\n    const agent = await db.agent.findFirst({ where: { tokenHash: await db.hash(tok) } });\n    if (!agent) return res.status(401).json({ error:'unauthorized' });\n    req.agent = agent; next();\n  } catch(e){ return res.status(500).json({ error:'auth error' }); }\n}\n\nmodule.exports = { requireAdmin, optionalAdmin, requireReg, requireAgentAuth };\n"
},
{
"id": "runner-controller-db",
"description": "Prisma client and helpers with argon2 hashing",
"op": "write_file",
"path": "modules/llm-runner-controller/server/db.js",
"mode": "overwrite",
"content": "// llm-runner-controller/server/db.js\nconst { PrismaClient } = require('@prisma/client');\nconst argon2 = require('argon2');\nconst crypto = require('crypto');\n\nconst prisma = new PrismaClient();\n\nasync function hash(token){\n  // stable hash to store; we prefix a static tag to avoid raw argon2id of short strings collisions\n  return argon2.hash(`agent:${token}`);\n}\n\nfunction id(){ return crypto.randomUUID(); }\n\nmodule.exports = { db: prisma, hash, id };\n"
},
{
"id": "runner-controller-services-registry",
"description": "Registry service",
"op": "write_file",
"path": "modules/llm-runner-controller/server/services/registry.js",
"mode": "overwrite",
"content": "// server/services/registry.js\nconst { db, hash, id } = require('../db');\n\nfunction safeAgent(a){\n  return { id: a.id, name: a.name, url: a.url, default_cwd: a.defaultCwd, group_id: a.groupId, labels: a.labels, status: a.status, last_seen_at: a.lastSeenAt, version: a.version };\n}\n\nexports.list = async (_req,res)=>{\n  const items = await db.agent.findMany({ orderBy: { name: 'asc' } });\n  res.json({ items: items.map(safeAgent) });\n};\n\nexports.get = async (req,res)=>{\n  const a = await db.agent.findUnique({ where: { id: req.params.id } });\n  if (!a) return res.status(404).json({ error:'not found' });\n  res.json({ agent: safeAgent(a) });\n};\n\nexports.remove = async (req,res)=>{\n  await db.agent.delete({ where: { id: req.params.id } }).catch(()=>{});\n  res.json({ ok:true });\n};\n\nexports.upsert = async (req,res)=>{\n  const { id: aid, name, url, token, default_cwd, group, labels } = req.body||{};\n  if (!name || !url || !token) return res.status(400).json({ error:'name, url, token required' });\n  const tokenHash = await hash(token);\n  const data = { name, url: url.replace(/\/+$/,''), tokenHash, defaultCwd: default_cwd||null, groupId: group||null, labels: labels||{} };\n  const agent = aid ? await db.agent.update({ where: { id: aid }, data }) : await db.agent.create({ data: { id: id(), ...data } });\n  res.json({ ok:true, agent: safeAgent(agent) });\n};\n\nexports.selfRegister = async (req,res)=>{\n  const { name, url, token, default_cwd } = req.body||{};\n  if (!name || !url || !token) return res.status(400).json({ ok:false, error:'name, url, token required' });\n  const agent = await db.agent.upsert({\n    where: { name },\n    update: { url: url.replace(/\/+$/,''), tokenHash: await hash(token), defaultCwd: default_cwd||null },\n    create: { id: id(), name, url: url.replace(/\/+$/,''), tokenHash: await hash(token), defaultCwd: default_cwd||null, status:'unknown' }\n  });\n  res.json({ ok:true, agent: safeAgent(agent) });\n};\n\nexports.catalog = async (_req,res)=>{\n  const items = await db.agent.findMany({ select: { id:true, name:true, defaultCwd:true, labels:true, status:true } });\n  res.json({ agents: items.map(a=>({ id:a.id, name:a.name, default_cwd:a.defaultCwd, labels:a.labels||{}, status:a.status||'unknown' })) });\n};\n"
},
{
"id": "runner-controller-services-health",
"description": "Health service with ping and proxy",
"op": "write_file",
"path": "modules/llm-runner-controller/server/services/health.js",
"mode": "overwrite",
"content": "// server/services/health.js\nconst axios = require('axios');\nconst { db } = require('../db');\n\nasync function ping(agent){\n  const t0 = Date.now();\n  try {\n    const r = await axios.get(`${agent.url}/health`, { headers: { Authorization: 'Bearer ' + (agent._token||'') }, timeout: 5000 });\n    await db.agent.update({ where: { id: agent.id }, data: { status: 'online', lastSeenAt: new Date() } });\n    return { ok:true, ms: Date.now()-t0, payload: r.data };\n  } catch(e){\n    await db.agent.update({ where: { id: agent.id }, data: { status: 'offline' } }).catch(()=>{});\n    return { ok:false, ms: Date.now()-t0, error: e.message };\n  }\n}\n\nexports.pingNow = async (req,res)=>{\n  const a = await db.agent.findUnique({ where: { id: req.params.id } });\n  if (!a) return res.status(404).json({ error:'not found' });\n  const r = await ping(a);\n  res.json(r);\n};\n\nexports.proxy = async (req,res)=>{\n  const a = await db.agent.findUnique({ where: { id: req.params.id } });\n  if (!a) return res.status(404).json({ error:'not found' });\n  try{\n    const r = await axios.get(`${a.url}/health`, { headers: { Authorization: 'Bearer DUMMY' }, timeout: 5000 });\n    res.json(r.data);\n  }catch(e){ res.status(502).json({ ok:false, error: e.message }); }\n};\n\n// simple interval health checker (best-effort)\nconst INTERVAL = Number(process.env.HEALTH_INTERVAL_SEC||15)*1000;\nsetInterval(async ()=>{\n  const list = await db.agent.findMany();\n  await Promise.all(list.map(a=>exports.pingNow({ params:{ id:a.id } }, { json: ()=>{} } )));\n}, INTERVAL);\n"
},
{
"id": "runner-controller-services-exec",
"description": "Exec proxy and auditing",
"op": "write_file",
"path": "modules/llm-runner-controller/server/services/exec.js",
"mode": "overwrite",
"content": "// server/services/exec.js\nconst axios = require('axios');\nconst { db, id } = require('../db');\n\nexports.run = async (req,res)=>{\n  const agent = await db.agent.findUnique({ where: { id: req.params.id } });\n  if (!agent) return res.status(404).json({ error:'not found' });\n\n  const { type, cmd, script, cwd, env, timeoutMs } = req.body||{};\n  const body = type==='bash' ? { type:'bash', cmd, cwd, env, timeoutMs } : { type:'python', script, cwd, env, timeoutMs };\n  const started = Date.now();\n  try {\n    const r = await axios.post(`${agent.url}/exec`, body, { headers: { Authorization: 'Bearer AGENT_TOKEN_UNAVAILABLE' }, timeout: (timeoutMs||20000)+4000 });\n    const dur = Date.now()-started;\n    const out = r.data||{};\n    await db.runLog.create({ data: { id: id(), agentId: agent.id, requester: 'llm-workflows', kind: String(type||''), codeHash: String((cmd||script||'')).slice(0,64), cwd: cwd||agent.defaultCwd||null, envRedacted: env?Object.keys(env):[], status: out.ok?'ok':'error', exitCode: out.exitCode??null, stdoutHead: String(out.stdout||'').slice(0,4000), stderrHead: String(out.stderr||'').slice(0,4000), durationMs: dur } });\n    res.json(out);\n  } catch(e){\n    const dur = Date.now()-started;\n    await db.runLog.create({ data: { id: id(), agentId: agent.id, requester:'llm-workflows', kind:String(type||''), codeHash: String((cmd||script||'')).slice(0,64), status:'error', stdoutHead:'', stderrHead: String(e.message||'').slice(0,4000), durationMs: dur } });\n    res.status(502).json({ ok:false, error: e.message });\n  }\n};\n"
},
{
"id": "runner-controller-services-configs",
"description": "Config layering endpoints",
"op": "write_file",
"path": "modules/llm-runner-controller/server/services/configs.js",
"mode": "overwrite",
"content": "// server/services/configs.js\nconst { db, id } = require('../db');\n\nfunction deepMerge(a,b){ if(!a) return b; if(!b) return a; if(Array.isArray(a)||Array.isArray(b)||typeof a!=='object'||typeof b!=='object') return b; const o={...a}; for(const k of Object.keys(b)) o[k]=deepMerge(a[k],b[k]); return o; }\n\nexports.list = async (req,res)=>{\n  const { scope, ref_id } = req.query;\n  const where = {};\n  if (scope) where.scope = scope; if (ref_id) where.refId = ref_id;\n  const items = await db.config.findMany({ where, orderBy: { createdAt:'desc' } });\n  res.json({ items });\n};\n\nexports.create = async (req,res)=>{\n  const { scope, ref_id, name, data } = req.body||{};\n  if (!scope || !['global','group','agent'].includes(scope)) return res.status(400).json({ error:'invalid scope' });\n  const c = await db.config.create({ data: { id: id(), scope, refId: ref_id||null, name: name||scope, data: data||{}, version: Date.now().toString() } });\n  res.json({ ok:true, id:c.id, version:c.version });\n};\n\nexports.assign = async (req,res)=>{\n  const agentId = req.params.id; const { config_id } = req.body||{};\n  const cfg = await db.config.findUnique({ where: { id: config_id } });\n  if (!cfg) return res.status(404).json({ error:'config not found' });\n  await db.assignment.create({ data: { agentId, configId: cfg.id, effectiveVersion: cfg.version } });\n  res.json({ ok:true, effective_version: cfg.version });\n};\n\nexports.effective = async (req,res)=>{\n  const agentId = req.params.id;\n  const a = await db.agent.findUnique({ where: { id: agentId } }); if(!a) return res.status(404).json({ error:'not found' });\n  const globals = await db.config.findMany({ where: { scope:'global' }, orderBy:{ createdAt:'asc' } });\n  const groups = a.groupId ? await db.config.findMany({ where: { scope:'group', refId:a.groupId }, orderBy:{ createdAt:'asc' } }) : [];\n  const agentCfgs = await db.config.findMany({ where: { scope:'agent', refId:a.id }, orderBy:{ createdAt:'asc' } });\n  let out = {}; for (const c of [...globals,...groups,...agentCfgs]) out = deepMerge(out, c.data||{});\n  res.json({ version: String((agentCfgs.at(-1)||groups.at(-1)||globals.at(-1)||{}).version||'0'), data: out });\n};\n\nexports.pullForAgent = async (req,res)=>{\n  const agentId = req.query.id || req.params.id; // allow both\n  req.params.id = agentId; return exports.effective(req,res);\n};\n"
},
{
"id": "runner-controller-services-updates",
"description": "Stub update endpoints",
"op": "write_file",
"path": "modules/llm-runner-controller/server/services/updates.js",
"mode": "overwrite",
"content": "// server/services/updates.js\nconst { db, id } = require('../db');\n\nexports.trigger = async (req,res)=>{\n  const upd = await db.updateTask.create({ data: { id: id(), agentId: req.params.id, target: req.body?.target||'unknown', strategy: req.body?.strategy||'now', status:'queued', logs:'' } });\n  // NOTE: Wire actual remote /update calls on the agent in a worker later.\n  res.json({ ok:true, update_id: upd.id });\n};\nexports.get = async (req,res)=>{\n  const upd = await db.updateTask.findUnique({ where: { id: req.params.updId } });\n  if (!upd) return res.status(404).json({ error:'not found' });\n  res.json(upd);\n};\n"
},
{
"id": "runner-controller-services-events",
"description": "Server-Sent Events bus (minimal)",
"op": "write_file",
"path": "modules/llm-runner-controller/server/services/events.js",
"mode": "overwrite",
"content": "// server/services/events.js\nconst clients = new Set();\nfunction send(ev){\n  const line = `data: ${JSON.stringify(ev)}\\n\\n`;\n  for (const res of clients){ try { res.write(line); } catch {} }\n}\nexports.emit = send;\nexports.sse = (req,res)=>{\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache');\n  res.setHeader('Connection', 'keep-alive');\n  res.flushHeaders?.();\n  res.write('retry: 10000\n\n');\n  clients.add(res);\n  req.on('close', ()=> clients.delete(res));\n};\n"
},
{
"id": "runner-controller-services-installers",
"description": "Serve installer scripts",
"op": "write_file",
"path": "modules/llm-runner-controller/server/services/installers.js",
"mode": "overwrite",
"content": "// server/services/installers.js\nexports.dockerScript = (req,res)=>{\n  const REG_TOKEN = process.env.RUNNER_REG_TOKEN || '';\n  const base = process.env.PUBLIC_EDGE_BASE || (req.protocol + '://' + req.headers.host);\n  res.type('text/x-shellscript');\n  res.send(`# runner docker installer\\nset -euo pipefail\\nREG_TOKEN='${REG_TOKEN}'\\nSERVER_BASE='${base}'\\n` +\n`cat <<'EOS' > /tmp/runner.sh\\n#!/usr/bin/env bash\\nset -euo pipefail\\n# args: --name, --server, --runner-url, --port, --token, --base-dir, --image, --allow-env\\n# ... (use your existing script body, but POST to ${base}/api/llm-runner/agents/register)\\nEOS\\n` +\n`bash /tmp/runner.sh --server \"$SERVER_BASE\"\\n`);\n};\n\nexports.systemdScript = (_req,res)=>{\n  res.type('text/x-shellscript');\n  res.send(`# systemd installer placeholder (adapt from modules/runner-agent/install.sh)\\n`);\n};\n"
},
{
"id": "runner-controller-prisma-schema",
"description": "Prisma schema (SQLite)",
"op": "write_file",
"path": "modules/llm-runner-controller/prisma/schema.prisma",
"mode": "overwrite",
"content": "generator client { provider = \"prisma-client-js\" }\ndatasource db { provider = \"sqlite\" url = env(\"DATABASE_URL\") }\n\nmodel Agent {\n  id           String   @id\n  name         String   @unique\n  url          String\n  tokenHash    String\n  defaultCwd   String?\n  groupId      String?\n  labels       Json?\n  version      String?  @default(\"0.1.0\")\n  status       String?  @default(\"unknown\")\n  lastSeenAt   DateTime?\n  createdAt    DateTime @default(now())\n  updatedAt    DateTime @updatedAt\n  runs         RunLog[]\n}\n\nmodel Config {\n  id        String   @id\n  scope     String\n  refId     String?\n  name      String\n  data      Json\n  version   String\n  createdAt DateTime @default(now())\n}\n\nmodel Assignment {\n  id              String   @id @default(uuid())\n  agentId         String\n  configId        String\n  effectiveVersion String\n  createdAt       DateTime @default(now())\n  agent           Agent    @relation(fields: [agentId], references: [id])\n  config          Config   @relation(fields: [configId], references: [id])\n}\n\nmodel RunLog {\n  id          String   @id\n  agentId     String\n  requester   String?\n  kind        String?\n  codeHash    String?\n  cwd         String?\n  envRedacted Json?\n  status      String?\n  exitCode    Int?\n  stdoutHead  String?\n  stderrHead  String?\n  durationMs  Int?\n  createdAt   DateTime @default(now())\n  agent       Agent    @relation(fields: [agentId], references: [id])\n}\n\nmodel UpdateTask {\n  id        String   @id\n  agentId   String\n  target    String\n  strategy  String?\n  status    String\n  logs      String?\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  agent     Agent    @relation(fields: [agentId], references: [id])\n}\n"
},
{
"id": "runner-controller-env",
"description": "Default env example for controller",
"op": "write_file",
"path": "modules/llm-runner-controller/.env.example",
"mode": "overwrite",
"content": "DATABASE_URL=\"file:./data/runner.db\"\nPORT=4015\nINTERNAL_API_TOKEN=supersecret\nRUNNER_REG_TOKEN=supersecret\nHEALTH_INTERVAL_SEC=15\nPUBLIC_EDGE_BASE=http://edge-nginx:80\n"
},
{
"id": "runner-controller-ignore",
"description": "dockerignore",
"op": "write_file",
"path": "modules/llm-runner-controller/.dockerignore",
"mode": "overwrite",
"content": "node_modules\nnpm-debug.log\n.DS_Store\n.prisma\n.env\n"
},
{
"id": "edge-nginx-https-block",
"description": "Add HTTPS routes for runner controller",
"op": "patch_text",
"path": "modules/edge-nginx/nginx.conf",
"patches": [
{
"type": "insert_after",
"anchor": "# --- HTTPS server ---",
"replacement": "\n    # LLM Runner Controller API\n    location /api/llm-runner/ {\n      proxy_http_version 1.1;\n      proxy_set_header Host $host;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n      proxy_set_header X-Forwarded-Proto https;\n      proxy_buffering off;\n      proxy_read_timeout 86400;\n      add_header 'Access-Control-Allow-Origin' $cors_header always;\n      add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE' always;\n      add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization' always;\n      add_header 'Access-Control-Allow-Credentials' 'true' always;\n      if ($request_method = OPTIONS) { return 204; }\n      proxy_pass http://llm-runner-controller:4015/api/llm-runner/;\n    }\n\n    # Runner installers via controller\n    location /install/runner.sh { proxy_pass http://llm-runner-controller:4015/install/runner.sh; }\n    location /install/systemd.sh { proxy_pass http://llm-runner-controller:4015/install/systemd.sh; }\n"
}
]
},
{
"id": "edge-nginx-http-block",
"description": "Add HTTP routes for runner controller (avoid TLS loops)",
"op": "patch_text",
"path": "modules/edge-nginx/nginx.conf",
"patches": [
{
"type": "insert_after",
"anchor": "# --- HTTP server (redirect to HTTPS; keep /health + internal API proxy to avoid TLS redirect loops from containers) ---",
"replacement": "\n    # Runner Controller API (HTTP internal)\n    location /api/llm-runner/ {\n      proxy_http_version 1.1;\n      proxy_set_header Host $host;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n      proxy_set_header X-Forwarded-Proto http;\n      proxy_buffering off;\n      proxy_read_timeout 86400;\n      add_header 'Access-Control-Allow-Origin' $cors_header always;\n      add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE' always;\n      add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization' always;\n      add_header 'Access-Control-Allow-Credentials' 'true' always;\n      if ($request_method = OPTIONS) { return 204; }\n      proxy_pass http://llm-runner-controller:4015/api/llm-runner/;\n    }\n\n    # Runner installers (HTTP)\n    location /install/runner.sh { proxy_pass http://llm-runner-controller:4015/install/runner.sh; }\n    location /install/systemd.sh { proxy_pass http://llm-runner-controller:4015/install/systemd.sh; }\n"
}
]
},
{
"id": "docker-compose-add-service",
"description": "Add llm-runner-controller service",
"op": "patch_text",
"path": "modules/docker-compose.yml",
"patches": [
{
"type": "insert_before",
"match": "networks:\n  app-network:",
"regex": false,
"replacement": "  llm-runner-controller:\n    build: ./llm-runner-controller\n    container_name: llm-runner-controller\n    environment:\n      - NODE_ENV=production\n      - PORT=4015\n      - INTERNAL_API_TOKEN=${INTERNAL_API_TOKEN:-supersecret}\n      - RUNNER_REG_TOKEN=${RUNNER_REG_TOKEN:-supersecret}\n      - DATABASE_URL=file:./data/runner.db\n      - HEALTH_INTERVAL_SEC=15\n    volumes:\n      - ./llm-runner-controller/data:/app/data\n    expose:\n      - \"4015\"\n    networks:\n      - app-network\n    restart: unless-stopped\n\nnetworks:\n  app-network:\n"
},
{
"type": "replace_regex",
"match": "edge-nginx:\n([\\s\\S]*?)depends_on:\n([\\s\\S]*?)networks:",
"replacement": "edge-nginx:\n$1depends_on:\n$2      - llm-runner-controller\n    networks:",
"regex": true
}
]
},
{
"id": "workflows-env-integration",
"description": "Ensure llm-workflows knows controller base URL",
"op": "patch_text",
"path": "modules/docker-compose.yml",
"patches": [
{
"type": "insert_after",
"anchor": "llm-workflows-module:",
"replacement": "\n    environment:\n      - RUNNER_CONTROLLER_BASE=http://llm-runner-controller:4015/api/llm-runner\n"
}
]
},
{
"id": "workflows-runnerclient-rewrite",
"description": "Switch llm-workflows runnerClient.js to call controller",
"op": "write_file",
"path": "modules/llm-workflows/server/runnerClient.js",
"mode": "overwrite",
"content": "// llm-workflows now delegates runner ops to llm-runner-controller\nconst axios = require('axios');\n\nconst BASE = process.env.RUNNER_CONTROLLER_BASE || 'http://llm-runner-controller:4015/api/llm-runner';\nfunction hdr(){\n  const t = process.env.INTERNAL_API_TOKEN || '';\n  return t ? { Authorization: `Bearer ${t}` } : {};\n}\n\nasync function listRunners(){\n  const r = await axios.get(`${BASE}/agents`, { headers: hdr(), timeout: 10000 });\n  return (r.data?.items||[]).map(a => ({ name: a.name, url: `controller:${a.id}`, default_cwd: a.default_cwd }));\n}\nasync function getRunner(name){ return { name, url: `controller:${name}` }; }\nasync function pingRunner(name){\n  const r = await axios.get(`${BASE}/agents/${encodeURIComponent(name)}/health`, { headers: hdr(), timeout: 8000 });\n  return r.data;\n}\nasync function execRemote({ target, kind, code, cwd, env, timeoutMs }){\n  const body = kind==='bash' ? { type:'bash', cmd:code, cwd, env, timeoutMs } : { type:'python', script:code, cwd, env, timeoutMs };\n  const r = await axios.post(`${BASE}/agents/${encodeURIComponent(target)}/exec`, body, { headers: hdr(), timeout: (timeoutMs||20000)+4000 });\n  return r.data;\n}\nmodule.exports = { listRunners, getRunner, upsertRunner:()=>{ throw new Error('admin-only via controller'); }, removeRunner:()=>{ throw new Error('admin-only via controller'); }, pingRunner, execRemote };\n"
},
{
"id": "workflows-app-installer-redirect",
"description": "Redirect old installer endpoint to controller",
"op": "patch_text",
"path": "modules/llm-workflows/server/app.js",
"patches": [
{
"type": "replace_regex",
"match": "app.get\('/install/runner\.sh'[\\s\\S]*?\);",
"replacement": "app.get('/install/runner.sh', (req,res)=>{\n  const base = process.env.RUNNER_CONTROLLER_BASE?.replace(/\/api\/llm-runner$/, '') || 'http://llm-runner-controller:4015';\n  res.redirect(302, `${base}/install/runner.sh`);\n});\n\nif (BASE_PATH) app.get(`${BASE_PATH}/install/runner.sh`, (req,res)=>{\n  const base = process.env.RUNNER_CONTROLLER_BASE?.replace(/\/api\/llm-runner$/, '') || 'http://llm-runner-controller:4015';\n  res.redirect(302, `${base}/install/runner.sh`);\n});",
"regex": true
}
]
},
{
"id": "controller-readme",
"description": "README for quickstart",
"op": "write_file",
"path": "modules/llm-runner-controller/README.md",
"mode": "overwrite",
"content": "# llm-runner-controller\n\nAPI-first control plane for runner-agents.\n\n## Env\n\n- `DATABASE_URL=file:./data/runner.db`\n- `INTERNAL_API_TOKEN=...`\n- `RUNNER_REG_TOKEN=...`\n\n## Dev\n\n`bash\ncd modules/llm-runner-controller\ncp .env.example .env\nnpm run prisma:generate\nnpm start\n`\n\n## API\n\n- `GET /api/llm-runner/agents`\n- `POST /api/llm-runner/agents/register` (Bearer RUNNER_REG_TOKEN)\n- `POST /api/llm-runner/agents/:id/exec` (Bearer INTERNAL_API_TOKEN)\n"
}
]
}