<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Logs - LLM Workflows</title>
  <link rel="stylesheet" href="./css/theme.css">
  <style>
    .debug-container { padding: 16px; max-width: 1400px; margin: 0 auto; }
    .log-entry { 
      background: #1a1a1a; 
      border: 1px solid #3e3e42; 
      border-radius: 6px; 
      padding: 12px; 
      margin-bottom: 8px;
      font-family: monospace;
      font-size: 12px;
    }
    .log-entry.debug { border-left: 3px solid #0e639c; }
    .log-entry.info { border-left: 3px solid #4ec9b0; }
    .log-entry.warn { border-left: 3px solid #f4bf75; }
    .log-entry.error { border-left: 3px solid #f48771; }
    .log-meta { 
      margin-top: 8px; 
      padding: 8px; 
      background: #111; 
      border-radius: 4px;
      white-space: pre-wrap;
      overflow-x: auto;
    }
    .filters { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
      gap: 12px; 
      margin-bottom: 16px;
    }
    .auto-scroll { 
      position: fixed; 
      bottom: 20px; 
      right: 20px; 
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="header">
    <strong>üîç Debug Logs</strong>
    <div class="grow"></div>
    <button class="ghost" id="backBtn">‚Üê Back to Workflows</button>
  </div>

  <div class="debug-container">
    <div class="card">
      <h3>Log Filters</h3>
      <div class="filters">
        <div>
          <label>Level</label>
          <select id="levelFilter">
            <option value="">All</option>
            <option value="debug">Debug</option>
            <option value="info">Info</option>
            <option value="warn">Warn</option>
            <option value="error">Error</option>
          </select>
        </div>
        <div>
          <label>Search</label>
          <input id="searchFilter" placeholder="Search logs...">
        </div>
        <div>
          <label>Correlation ID</label>
          <input id="corrFilter" placeholder="Run ID or correlation ID">
        </div>
        <div>
          <label>Limit</label>
          <input id="limitFilter" type="number" value="500" min="100" max="2000">
        </div>
      </div>
      <div class="horz" style="gap: 8px;">
        <button id="refreshBtn" class="btn">üîÑ Refresh</button>
        <button id="clearBtn" class="ghost">Clear Logs</button>
        <button id="exportBtn" class="ghost">üì• Export</button>
        <label style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="autoScroll" checked>
          Auto-scroll
        </label>
        <label style="display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="liveStream">
          Live Stream
        </label>
      </div>
    </div>

    <div class="card">
      <div id="logCount" class="muted small" style="margin-bottom: 12px;">Loading logs...</div>
      <div id="logContainer"></div>
    </div>
  </div>

  <script>
    const API_BASE = './api';
    let eventSource = null;

    document.getElementById('backBtn').addEventListener('click', () => {
      window.location.href = './';
    });

    async function loadLogs() {
      const level = document.getElementById('levelFilter').value;
      const search = document.getElementById('searchFilter').value;
      const corr = document.getElementById('corrFilter').value;
      const limit = document.getElementById('limitFilter').value;

      const params = new URLSearchParams();
      if (level) params.set('level', level);
      if (search) params.set('search', search);
      if (corr) params.set('corr', corr);
      if (limit) params.set('limit', limit);

      try {
        const resp = await fetch(`${API_BASE}/debug/logs?${params}`);
        const data = await resp.json();
        renderLogs(data.logs);
        document.getElementById('logCount').textContent = `Showing ${data.logs.length} logs`;
      } catch (e) {
        console.error('Failed to load logs:', e);
        document.getElementById('logCount').textContent = 'Failed to load logs';
      }
    }

    function renderLogs(logs) {
      const container = document.getElementById('logContainer');
      const shouldScroll = document.getElementById('autoScroll').checked;
      const wasAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 100;

      container.innerHTML = logs.map(log => `
        <div class="log-entry ${log.level}">
          <div>
            <span style="color: #969696;">[${log.ts}]</span>
            <span style="color: ${getLevelColor(log.level)}; font-weight: bold;">[${log.level.toUpperCase()}]</span>
            <span>${escapeHtml(log.msg)}</span>
          </div>
          ${log.meta ? `<div class="log-meta">${escapeHtml(JSON.stringify(log.meta, null, 2))}</div>` : ''}
        </div>
      `).join('');

      if (shouldScroll && wasAtBottom) {
        container.scrollTop = container.scrollHeight;
      }
    }

    function getLevelColor(level) {
      const colors = {
        debug: '#0e639c',
        info: '#4ec9b0',
        warn: '#f4bf75',
        error: '#f48771'
      };
      return colors[level] || '#d4d4d4';
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    function startLiveStream() {
      if (eventSource) {
        eventSource.close();
      }

      const level = document.getElementById('levelFilter').value;
      const search = document.getElementById('searchFilter').value;
      const params = new URLSearchParams();
      if (level) params.set('level', level);
      if (search) params.set('search', search);

      eventSource = new EventSource(`${API_BASE}/debug/logs/stream?${params}`);
      
      eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'initial') {
          renderLogs(data.logs);
        } else if (data.type === 'update') {
          const container = document.getElementById('logContainer');
          const newLogs = data.logs.map(log => `
            <div class="log-entry ${log.level}">
              <div>
                <span style="color: #969696;">[${log.ts}]</span>
                <span style="color: ${getLevelColor(log.level)}; font-weight: bold;">[${log.level.toUpperCase()}]</span>
                <span>${escapeHtml(log.msg)}</span>
              </div>
              ${log.meta ? `<div class="log-meta">${escapeHtml(JSON.stringify(log.meta, null, 2))}</div>` : ''}
            </div>
          `).join('');
          
          container.insertAdjacentHTML('beforeend', newLogs);
          
          if (document.getElementById('autoScroll').checked) {
            container.scrollTop = container.scrollHeight;
          }
        }
      };

      eventSource.onerror = () => {
        console.error('SSE connection error');
        document.getElementById('liveStream').checked = false;
        stopLiveStream();
      };
    }

    function stopLiveStream() {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
    }

    async function clearLogs() {
      if (!confirm('Clear all logs?')) return;
      try {
        await fetch(`${API_BASE}/logs/clear`, { method: 'POST' });
        loadLogs();
      } catch (e) {
        alert('Failed to clear logs');
      }
    }

    async function exportLogs() {
      const level = document.getElementById('levelFilter').value;
      const search = document.getElementById('searchFilter').value;
      const corr = document.getElementById('corrFilter').value;
      const limit = document.getElementById('limitFilter').value;

      const params = new URLSearchParams({ format: 'text' });
      if (level) params.set('level', level);
      if (search) params.set('search', search);
      if (corr) params.set('corr', corr);
      if (limit) params.set('limit', limit);

      const resp = await fetch(`${API_BASE}/debug/logs?${params}`);
      const text = await resp.text();
      
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `logs-${new Date().toISOString()}.txt`;
      a.click();
      URL.revokeObjectURL(url);
    }

    document.getElementById('refreshBtn').addEventListener('click', loadLogs);
    document.getElementById('clearBtn').addEventListener('click', clearLogs);
    document.getElementById('exportBtn').addEventListener('click', exportLogs);

    document.getElementById('levelFilter').addEventListener('change', () => {
      if (document.getElementById('liveStream').checked) {
        stopLiveStream();
        startLiveStream();
      } else {
        loadLogs();
      }
    });

    document.getElementById('searchFilter').addEventListener('input', () => {
      if (document.getElementById('liveStream').checked) {
        stopLiveStream();
        startLiveStream();
      }
    });

    document.getElementById('liveStream').addEventListener('change', (e) => {
      if (e.target.checked) {
        startLiveStream();
      } else {
        stopLiveStream();
        loadLogs();
      }
    });

    // Initial load
    loadLogs();
  </script>
</body>
</html>