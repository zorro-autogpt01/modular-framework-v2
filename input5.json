{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "version": "1.0",
  "project_root": "",
  "dry_run": false,
  "backup": true,
  "changes": [
    {
      "id": "css-add-copy-button-to-messages",
      "description": "Add styles for copy button inside each message bubble and make room for it.",
      "op": "patch_text",
      "path": "modules/llm-chat/public/css/theme.css",
      "patches": [
        {
          "type": "replace_literal",
          "match": "/* Messages area */\n.msgs { flex: 1; overflow: auto; background: var(--bg); padding: 16px; }\n.msg { max-width: 90%; padding: 10px 12px; border-radius: 8px; margin-bottom: 10px; white-space: pre-wrap; word-wrap: break-word; }\n.user { background: #2a2a2a; align-self: flex-end; }\n.assistant { background: #1f2a33; border: 1px solid #203747; }",
          "replacement": "/* Messages area */\n.msgs { flex: 1; overflow: auto; background: var(--bg); padding: 16px; }\n.msg { max-width: 90%; padding: 10px 12px; border-radius: 8px; margin-bottom: 10px; white-space: pre-wrap; word-wrap: break-word; position: relative; padding-right: 48px; }\n.msg .msg-text { display: block; }\n.user { background: #2a2a2a; align-self: flex-end; }\n.assistant { background: #1f2a33; border: 1px solid #203747; }\n\n/* Copy button inside message bubbles */\n.msg .copy-btn {\n  position: absolute;\n  top: 6px;\n  right: 6px;\n  padding: 4px 8px;\n  font-size: 11px;\n  border-radius: 6px;\n  background: rgba(0,0,0,0.2);\n  color: var(--txt);\n  border: 1px solid rgba(255,255,255,0.06);\n  cursor: pointer;\n}\n.msg .copy-btn:hover { filter: brightness(1.08); }\n.msg .copy-btn.success { background: #2f8f5a; border-color: #1f6a4d; color: #fff; }\n"
        }
      ]
    },
    {
      "id": "ui-js-create-msg-element-and-copy",
      "description": "Create helper to render message elements with an integrated copy-to-clipboard button. Update addMsg to use it and export createMsgElement and copyToClipboard for use by chat logic.",
      "op": "write_file",
      "path": "modules/llm-chat/public/js/ui.js",
      "content": "export const getEl = (id)=> document.getElementById(id);\n\nexport function setBusy(b) {\n  const dot = getEl('dot'); const st = getEl('statusText');\n  if (!dot || !st) return;\n  if (b) { dot.classList.add('on'); st.textContent = 'Streamingâ€¦'; }\n  else   { dot.classList.remove('on'); st.textContent = 'Idle'; }\n}\n\n// Copy helper (navigator.clipboard fallback)\nexport async function copyToClipboard(text) {\n  try {\n    if (navigator.clipboard && navigator.clipboard.writeText) {\n      await navigator.clipboard.writeText(text);\n      return true;\n    }\n  } catch (e) {\n    // fallthrough to textarea fallback\n  }\n  try {\n    const ta = document.createElement('textarea');\n    ta.value = text;\n    ta.style.position = 'fixed'; ta.style.opacity = '0';\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand('copy');\n    document.body.removeChild(ta);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// Create a message DOM element with a dedicated .msg-text span and a copy button.\n// Copy action copies the visible text (innerText) of the .msg-text node.\nexport function createMsgElement(role, text) {\n  const el = document.createElement('div');\n  el.className = `msg ${role === 'user' ? 'user' : 'assistant'}`;\n\n  const span = document.createElement('span');\n  span.className = 'msg-text';\n  // preserve newline rendering via textContent\n  span.textContent = text || '';\n  el.appendChild(span);\n\n  const btn = document.createElement('button');\n  btn.type = 'button';\n  btn.className = 'copy-btn';\n  btn.title = 'Copy to clipboard';\n  btn.textContent = 'Copy';\n\n  btn.addEventListener('click', async () => {\n    const success = await copyToClipboard(span.innerText || span.textContent || '');\n    if (success) {\n      btn.classList.add('success');\n      const prev = btn.textContent;\n      btn.textContent = 'Copied';\n      setTimeout(() => { btn.classList.remove('success'); btn.textContent = prev; }, 1500);\n    } else {\n      // basic fallback alert if copy failed\n      alert('Copy failed â€” select and copy manually');\n    }\n  });\n\n  el.appendChild(btn);\n  return el;\n}\n\nexport function addMsg(role, content) {\n  const msgs = getEl('msgs'); if (!msgs) return;\n  const el = createMsgElement(role, content);\n  msgs.appendChild(el); msgs.scrollTop = msgs.scrollHeight;\n  return el;\n}\n\nexport function toast(msg){ alert(msg); }\n\n/** Detects the base path of the module (handles /, /modules/llm-chat/, and /modules/llm-chat/config) */\nexport function detectBasePath() {\n  const p = window.location.pathname;\n  const base = p.replace(/\\/config\\/?$/, '/');\n  return base.endsWith('/') ? base : (base + '/');\n}\n\n/** Sub-tab helper for Settings (switches between 'global' and 'profiles') */\nexport function showTab(tab){\n  const map = { global:'tGlobal', profiles:'tProfiles' };\n  Object.entries(map).forEach(([id, tabId])=>{\n    const tabEl = getEl(tabId); const pane = getEl(id);\n    if (!tabEl || !pane) return;\n    tabEl.classList.toggle('active', tab===id);\n    pane.style.display = tab===id ? '' : 'none';\n  });\n}\n"
    },
    {
      "id": "chat-js-use-createMsgElement-for-placeholders-and-history",
      "description": "Update chat logic to use createMsgElement and to update placeholder text via .msg-text to preserve copy button behavior and to copy final assistant text into conversation state.",
      "op": "patch_text",
      "path": "modules/llm-chat/public/js/chat.js",
      "patches": [
        {
          "type": "replace_literal",
          "match": "import { getGlobal, getProfiles, getActiveName } from './storage.js';\nimport { parseStream } from './sse.js';\nimport { getEl, setBusy, addMsg, detectBasePath } from './ui.js';",
          "replacement": "import { getGlobal, getProfiles, getActiveName } from './storage.js';\nimport { parseStream } from './sse.js';\nimport { getEl, setBusy, addMsg, detectBasePath, createMsgElement } from './ui.js';"
        },
        {
          "type": "replace_literal",
          "match": "function displayConversationHistory() {\n  const msgsDiv = getEl('msgs');\n  if (!msgsDiv) return;\n  \n  msgsDiv.innerHTML = '';\n  state.messages.forEach(msg => {\n    const el = document.createElement('div');\n    el.className = `msg ${msg.role === 'user' ? 'user' : 'assistant'}`;\n    el.textContent = msg.content;\n    msgsDiv.appendChild(el);\n  });\n  msgsDiv.scrollTop = msgsDiv.scrollHeight;\n}\n",
          "replacement": "function displayConversationHistory() {\n  const msgsDiv = getEl('msgs');\n  if (!msgsDiv) return;\n\n  msgsDiv.innerHTML = '';\n  state.messages.forEach(msg => {\n    const el = createMsgElement(msg.role === 'user' ? 'user' : 'assistant', msg.content || '');\n    msgsDiv.appendChild(el);\n  });\n  msgsDiv.scrollTop = msgsDiv.scrollHeight;\n}\n"
        },
        {
          "type": "replace_literal",
          "match": "  const placeholder = document.createElement('div');\n  placeholder.className = 'msg assistant';\n  placeholder.textContent = 'ðŸ”Ž Summarizingâ€¦';\n  const msgsDiv = getEl('msgs'); msgsDiv.appendChild(placeholder); msgsDiv.scrollTop = msgsDiv.scrollHeight;\n\n  setBusy(true);\n  const controller = new AbortController(); state.controller = controller;\n  try{\n",
          "replacement": "  const placeholder = createMsgElement('assistant', 'ðŸ”Ž Summarizingâ€¦');\n  const msgsDiv = getEl('msgs'); msgsDiv.appendChild(placeholder); msgsDiv.scrollTop = msgsDiv.scrollHeight;\n\n  setBusy(true);\n  const controller = new AbortController(); state.controller = controller;\n  try{\n"
        },
        {
          "type": "replace_literal",
          "match": "    const pump = parseStream(\n      (d)=> { placeholder.textContent += d; },\n      ()=> { state.messages.push({ role:'assistant', content: placeholder.textContent }); },\n      (m)=> { placeholder.textContent += `\\n[error] ${m}`; }\n    );",
          "replacement": "    const msgTextEl = placeholder.querySelector('.msg-text');\n    const pump = parseStream(\n      (d)=> { msgTextEl.textContent += d; },\n      ()=> { state.messages.push({ role:'assistant', content: msgTextEl.textContent }); },\n      (m)=> { msgTextEl.textContent += `\\n[error] ${m}`; }\n    );"
        },
        {
          "type": "replace_literal",
          "match": "    while (true) {\n      const { value, done } = await reader.read();\n      if (done) break;\n      if (value) pump(decoder.decode(value, { stream:true }));\n    }\n  } catch (e) {\n    placeholder.textContent += `\\n[stopped] ${e.message}`;\n  } finally {\n    setBusy(false); state.controller=null;\n  }\n}",
          "replacement": "    while (true) {\n      const { value, done } = await reader.read();\n      if (done) break;\n      if (value) pump(decoder.decode(value, { stream:true }));\n    }\n  } catch (e) {\n    const msgTextEl = placeholder.querySelector('.msg-text');\n    if (msgTextEl) msgTextEl.textContent += `\\n[stopped] ${e.message}`;\n  } finally {\n    setBusy(false); state.controller=null;\n  }\n}"
        },
        {
          "type": "replace_literal",
          "match": "  const placeholder = document.createElement('div');\n  placeholder.className = 'msg assistant'; \n  placeholder.textContent = '';\n  const msgsDiv = getEl('msgs');\n  msgsDiv.appendChild(placeholder); \n  msgsDiv.scrollTop = msgsDiv.scrollHeight;\n  state.messages.push({ role:'user', content: text });\n  input.value='';\n",
          "replacement": "  const placeholder = createMsgElement('assistant', '');\n  const msgsDiv = getEl('msgs');\n  msgsDiv.appendChild(placeholder);\n  msgsDiv.scrollTop = msgsDiv.scrollHeight;\n  state.messages.push({ role:'user', content: text });\n  input.value='';\n"
        },
        {
          "type": "replace_literal",
          "match": "    const pump = parseStream(\n      (d)=> { placeholder.textContent += d; },\n      ()=> { state.messages.push({ role:'assistant', content: placeholder.textContent }); \n        updateMessageCount();\n        // Display RAG sources if used\n        if (ragResponse && ragResponse.sources) {\n          displaySources(ragResponse.sources);\n        }\n        if (memorySnippets.length) {\n         displayMemories(memorySnippets);\n       }\n        // Auto-save every 10 messages\n        if (state.messages.length % 10 === 0) {\n          saveConversation();\n        }\n      },\n      (m)=> { placeholder.textContent += `\\n[error] ${m}`; }\n    );",
          "replacement": "    const msgTextEl = placeholder.querySelector('.msg-text');\n    const pump = parseStream(\n      (d)=> { msgTextEl.textContent += d; },\n      ()=> { \n        const finalText = msgTextEl.textContent || '';\n        state.messages.push({ role:'assistant', content: finalText }); \n        updateMessageCount();\n        // Display RAG sources if used\n        if (ragResponse && ragResponse.sources) {\n          displaySources(ragResponse.sources);\n        }\n        if (memorySnippets.length) {\n         displayMemories(memorySnippets);\n       }\n        // Auto-save every 10 messages\n        if (state.messages.length % 10 === 0) {\n          saveConversation();\n        }\n      },\n      (m)=> { msgTextEl.textContent += `\\n[error] ${m}`; }\n    );"
        },
        {
          "type": "replace_literal",
          "match": "    while (true) {\n      const { value, done } = await reader.read();\n      if (done) break;\n      if (value) pump(decoder.decode(value, { stream:true }));\n    }\n  } catch (e) {\n    placeholder.textContent += `\\n[stopped] ${e.message}`;\n  } finally {\n    setBusy(false); state.controller=null;\n  }\n}",
          "replacement": "    while (true) {\n      const { value, done } = await reader.read();\n      if (done) break;\n      if (value) pump(decoder.decode(value, { stream:true }));\n    }\n  } catch (e) {\n    const msgTextEl = placeholder.querySelector('.msg-text');\n    if (msgTextEl) msgTextEl.textContent += `\\n[stopped] ${e.message}`;\n  } finally {\n    setBusy(false); state.controller=null;\n  }\n}"
        },
        {
          "type": "replace_literal",
          "match": "        // Show the RAG answer\n        const ragMsg = document.createElement('div');\n        ragMsg.className = 'msg assistant';\n        ragMsg.innerHTML = `<span class=\"rag-badge\">RAG</span> ${ragResponse?.answer || ''}`;\n        msgsDiv.appendChild(ragMsg);\n\n        // Panels: RAG sources + tagged memories (if enabled)\n        if (ragResponse?.sources) displaySources(ragResponse.sources);\n        if (useMemories && memorySnippets.length) displayMemories(memorySnippets);\n\n        // Persist both in the local transcript\n        state.messages.push({ role:'user', content: text });\n        const storedAnswer = (ragResponse?.answer || '') + (useMemories && memorySnippets.length ? `\\n\\n[memories used: ${memorySnippets.length}]` : '');\n        state.messages.push({ role:'assistant', content: storedAnswer });\n\n        input.value = '';\n        updateMessageCount();\n\n        if (state.messages.length % 10 === 0) await saveConversation();\n        return;",
          "replacement": "        // Show the RAG answer\n        const ragMsg = createMsgElement('assistant', '');\n        const txt = ragMsg.querySelector('.msg-text');\n        if (txt) txt.innerHTML = `<span class=\"rag-badge\">RAG</span> ${ragResponse?.answer || ''}`;\n        msgsDiv.appendChild(ragMsg);\n\n        // Panels: RAG sources + tagged memories (if enabled)\n        if (ragResponse?.sources) displaySources(ragResponse.sources);\n        if (useMemories && memorySnippets.length) displayMemories(memorySnippets);\n\n        // Persist both in the local transcript\n        state.messages.push({ role:'user', content: text });\n        const storedAnswer = (ragResponse?.answer || '') + (useMemories && memorySnippets.length ? `\\n\\n[memories used: ${memorySnippets.length}]` : '');\n        state.messages.push({ role:'assistant', content: storedAnswer });\n\n        input.value = '';\n        updateMessageCount();\n\n        if (state.messages.length % 10 === 0) await saveConversation();\n        return;"
        }
      ]
    }
  ]
}